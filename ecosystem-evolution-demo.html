<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <title>ç”Ÿæ€ç³»ç»Ÿæ¼”åŒ–å¯è§†åŒ– | Ecosystem Evolution Framework</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --bg-card: rgba(51, 65, 85, 0.4);
      --bg-input: rgba(15, 23, 42, 0.8);
      --border-color: rgba(71, 85, 105, 0.5);
      --text-primary: #f1f5f9;
      --text-secondary: #e2e8f0;
      --text-muted: #94a3b8;
      --text-dim: #64748b;
      --accent-primary: #6366f1;
      --accent-secondary: #8b5cf6;
      --canvas-bg: #0f172a;
    }

    .light-mode {
      --bg-primary: #f8fafc;
      --bg-secondary: #f1f5f9;
      --bg-tertiary: #e2e8f0;
      --bg-card: rgba(226, 232, 240, 0.6);
      --bg-input: rgba(255, 255, 255, 0.9);
      --border-color: rgba(148, 163, 184, 0.5);
      --text-primary: #0f172a;
      --text-secondary: #1e293b;
      --text-muted: #475569;
      --text-dim: #64748b;
      --accent-primary: #6366f1;
      --accent-secondary: #8b5cf6;
      --canvas-bg: #ffffff;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 50%, var(--bg-primary) 100%);
      color: var(--text-secondary);
      min-height: 100vh;
      overflow: hidden;
      transition: background 0.3s, color 0.3s;
    }

    .header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border-color);
      padding: 6px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      height: 40px;
      transition: background 0.3s;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .header h1 {
      font-size: 13px;
      font-weight: 600;
      color: var(--text-primary);
    }

    .header h1 span {
      font-size: 9px;
      font-weight: 400;
      color: var(--text-dim);
      margin-left: 4px;
    }

    .auto-save-indicator {
      font-size: 8px;
      color: var(--text-dim);
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .auto-save-indicator.saving {
      color: #10B981;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .btn {
      padding: 3px 8px;
      font-size: 9px;
      font-weight: 500;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 3px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px solid var(--border-color);
    }

    .btn:hover {
      opacity: 0.85;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: white;
      border: none;
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.4);
    }

    .btn-icon {
      padding: 3px 5px;
    }

    .project-selector {
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      padding: 3px 6px;
      color: var(--text-secondary);
      font-size: 9px;
      min-width: 100px;
      cursor: pointer;
    }

    .mode-toggle {
      display: flex;
      align-items: center;
      gap: 3px;
      font-size: 9px;
      color: var(--text-muted);
      cursor: pointer;
      padding: 3px 6px;
      border-radius: 3px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
    }

    .mode-toggle:hover {
      background: var(--bg-card);
    }

    /* ç¼©æ”¾æ§åˆ¶ */
    .zoom-controls {
      display: flex;
      align-items: center;
      gap: 3px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      padding: 2px 4px;
    }

    .zoom-btn {
      width: 18px;
      height: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 2px;
      font-size: 12px;
      font-weight: bold;
    }

    .zoom-btn:hover {
      background: var(--bg-card);
    }

    .zoom-value {
      font-size: 9px;
      color: var(--text-muted);
      min-width: 32px;
      text-align: center;
    }

    .canvas-size-input {
      width: 45px;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 2px;
      padding: 2px 4px;
      color: var(--text-secondary);
      font-size: 9px;
      text-align: center;
      outline: none;
    }

    .canvas-size-input:focus {
      border-color: var(--accent-primary);
    }

    .canvas-size-input::-webkit-inner-spin-button,
    .canvas-size-input::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    .main-container {
      display: flex;
      height: calc(100vh - 40px);
      margin-top: 40px;
      position: relative;
    }

    .sidebar {
      width: 240px;
      min-width: 160px;
      max-width: 360px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      transition: width 0.05s ease, background 0.3s;
      position: relative;
      flex-shrink: 0;
    }

    .sidebar.collapsed {
      width: 0 !important;
      min-width: 0;
      border-right: none;
    }

    .sidebar.collapsed .sidebar-content {
      opacity: 0;
      pointer-events: none;
    }

    .sidebar-content {
      display: flex;
      flex-direction: column;
      height: 100%;
      transition: opacity 0.2s;
      overflow: hidden;
    }

    .sidebar-resizer {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      cursor: ew-resize;
      background: transparent;
      transition: background 0.2s;
      z-index: 10;
    }

    .sidebar-resizer:hover,
    .sidebar-resizer.dragging {
      background: var(--accent-primary);
    }

    .sidebar-toggle {
      position: absolute;
      left: 240px;
      top: 8px;
      width: 16px;
      height: 32px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-left: none;
      border-radius: 0 4px 4px 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      transition: left 0.05s ease, background 0.2s;
      z-index: 50;
    }

    .sidebar-toggle:hover {
      background: var(--bg-card);
      color: var(--text-secondary);
    }

    .sidebar.collapsed~.sidebar-toggle {
      left: 0;
    }

    .sidebar-toggle svg {
      transition: transform 0.3s;
    }

    .sidebar.collapsed~.sidebar-toggle svg {
      transform: rotate(180deg);
    }

    .tab-nav {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
      padding: 5px;
      background: var(--bg-primary);
      border-bottom: 1px solid var(--border-color);
    }

    .tab-btn {
      padding: 2px 6px;
      font-size: 8px;
      font-weight: 500;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
      background: transparent;
      color: var(--text-muted);
    }

    .tab-btn:hover {
      background: var(--bg-card);
      color: var(--text-secondary);
    }

    .tab-btn.active {
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      color: white;
    }

    .tab-content {
      flex: 1;
      overflow-y: auto;
      padding: 6px;
    }

    .tab-panel {
      display: none;
    }

    .tab-panel.active {
      display: block;
    }

    .section-title {
      font-size: 8px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .add-section {
      background: var(--bg-primary);
      border-radius: 4px;
      padding: 6px;
      margin-bottom: 6px;
    }

    .symbol-buttons {
      display: flex;
      gap: 2px;
    }

    .symbol-btn {
      flex: 1;
      padding: 6px 2px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 12px;
    }

    .symbol-btn:hover {
      background: var(--bg-tertiary);
      transform: translateY(-1px);
    }

    .add-btn {
      width: 100%;
      padding: 6px;
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border: none;
      border-radius: 3px;
      color: white;
      font-size: 9px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .add-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
    }

    .add-btn-secondary {
      background: transparent;
      border: 1px dashed var(--border-color);
      color: var(--text-muted);
    }

    .add-btn-secondary:hover {
      background: var(--bg-card);
      box-shadow: none;
    }

    .item-card {
      background: var(--bg-card);
      border-radius: 4px;
      padding: 6px;
      margin-bottom: 3px;
      cursor: pointer;
      transition: all 0.2s;
      border: 2px solid transparent;
    }

    .item-card:hover {
      background: var(--bg-tertiary);
    }

    .item-card.selected {
      border-color: var(--accent-primary);
      box-shadow: 0 0 6px rgba(99, 102, 241, 0.3);
    }

    .item-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 3px;
    }

    .item-info {
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .item-symbol {
      font-size: 11px;
    }

    .item-input {
      background: transparent;
      border: none;
      border-bottom: 1px solid transparent;
      color: var(--text-secondary);
      font-size: 9px;
      padding: 1px 0;
      width: 70px;
      outline: none;
    }

    .item-input:hover {
      border-bottom-color: var(--border-color);
    }

    .item-input:focus {
      border-bottom-color: var(--accent-primary);
    }

    .delete-btn {
      width: 14px;
      height: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: transparent;
      border: none;
      color: var(--text-dim);
      cursor: pointer;
      border-radius: 2px;
      font-size: 10px;
    }

    .delete-btn:hover {
      background: rgba(239, 68, 68, 0.1);
      color: #ef4444;
    }

    .item-select {
      width: 100%;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 2px;
      padding: 2px 4px;
      color: var(--text-muted);
      font-size: 8px;
      outline: none;
    }

    .item-row {
      display: flex;
      align-items: center;
      gap: 3px;
      margin-top: 3px;
    }

    .item-label {
      font-size: 7px;
      color: var(--text-dim);
      white-space: nowrap;
    }

    /* é¢œè‰²é€‰æ‹©å™¨ - ä¸‹æ‹‰æ–¹æ¡ˆ */
    .color-picker-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      gap: 2px;
    }

    .color-picker {
      width: 18px;
      height: 18px;
      border: none;
      border-radius: 2px;
      cursor: pointer;
      padding: 0;
      background: transparent;
    }

    .color-scheme-triggers {
      display: flex;
      gap: 1px;
    }

    .color-scheme-trigger {
      width: 12px;
      height: 12px;
      border-radius: 2px;
      cursor: pointer;
      border: 1px solid transparent;
      transition: all 0.2s;
      position: relative;
    }

    .color-scheme-trigger:hover {
      transform: scale(1.15);
      border-color: var(--text-primary);
      z-index: 10;
    }

    .color-scheme-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 4px;
      display: none;
      flex-direction: column;
      gap: 2px;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      min-width: 80px;
    }

    .color-scheme-trigger:hover .color-scheme-dropdown {
      display: flex;
    }

    .color-scheme-dropdown-row {
      display: flex;
      gap: 2px;
    }

    .color-scheme-color {
      width: 14px;
      height: 14px;
      border-radius: 2px;
      cursor: pointer;
      border: 1px solid transparent;
      transition: all 0.15s;
    }

    .color-scheme-color:hover {
      transform: scale(1.2);
      border-color: white;
    }

    .color-preview {
      width: 9px;
      height: 9px;
      border-radius: 2px;
      flex-shrink: 0;
    }

    .attr-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
      margin-top: 3px;
    }

    .attr-tag {
      padding: 1px 3px;
      border-radius: 2px;
      font-size: 7px;
      cursor: pointer;
      transition: all 0.2s;
      background: var(--bg-input);
      color: var(--text-dim);
      border: none;
    }

    .attr-tag.active {
      color: white;
    }

    .config-input {
      flex: 1;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 2px;
      padding: 2px 4px;
      color: var(--text-secondary);
      font-size: 8px;
      outline: none;
    }

    .config-input:focus {
      border-color: var(--accent-primary);
    }

    .config-input.small {
      width: 40px;
      flex: none;
    }

    .phase-visibility {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
      margin-top: 3px;
    }

    .phase-check {
      display: flex;
      align-items: center;
      gap: 1px;
      font-size: 7px;
      color: var(--text-muted);
    }

    .phase-check input {
      accent-color: var(--accent-primary);
      width: 9px;
      height: 9px;
    }

    .tip-box {
      background: var(--bg-primary);
      border-radius: 3px;
      padding: 5px;
      margin-top: 6px;
    }

    .tip-box p {
      font-size: 7px;
      color: var(--text-dim);
      line-height: 1.4;
    }

    .singularity-card {
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.1), rgba(139, 92, 246, 0.1));
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 5px;
      padding: 8px;
    }

    .singularity-input {
      width: 100%;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      padding: 5px 7px;
      color: var(--text-secondary);
      font-size: 10px;
      outline: none;
      margin-bottom: 5px;
    }

    .singularity-input:focus {
      border-color: var(--accent-primary);
    }

    .singularity-input.large {
      font-size: 12px;
      font-weight: 600;
    }

    .singularity-textarea {
      width: 100%;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      padding: 5px 7px;
      color: var(--text-muted);
      font-size: 9px;
      outline: none;
      resize: vertical;
      min-height: 40px;
      font-family: inherit;
    }

    .singularity-textarea:focus {
      border-color: var(--accent-primary);
    }

    /* æ ·å¼è®¾ç½®é¢æ¿ */
    .style-section {
      background: var(--bg-card);
      border-radius: 4px;
      padding: 6px;
      margin-bottom: 6px;
    }

    .style-section-title {
      font-size: 9px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 6px;
      padding-bottom: 3px;
      border-bottom: 1px solid var(--border-color);
    }

    .style-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .style-label {
      font-size: 8px;
      color: var(--text-muted);
    }

    .style-control {
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .style-input {
      width: 45px;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 2px;
      padding: 2px 4px;
      color: var(--text-secondary);
      font-size: 8px;
      outline: none;
      text-align: center;
    }

    .style-unit {
      font-size: 7px;
      color: var(--text-dim);
    }

    .style-range {
      width: 60px;
    }

    /* å±‚çº§é«˜åº¦è°ƒæ•´ */
    .layer-height-control {
      display: flex;
      align-items: center;
      gap: 3px;
      margin-top: 3px;
    }

    .layer-height-input {
      width: 40px;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 2px;
      padding: 2px 4px;
      color: var(--text-secondary);
      font-size: 8px;
      outline: none;
      text-align: center;
    }

    .canvas-area {
      flex: 1;
      padding: 10px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    .canvas-container {
      background: var(--bg-card);
      border-radius: 6px;
      border: 1px solid var(--border-color);
      padding: 6px;
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .canvas-toolbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
      flex-shrink: 0;
    }

    .canvas-hint {
      font-size: 8px;
      color: var(--text-dim);
    }

    .canvas-toggle {
      display: flex;
      align-items: center;
      gap: 3px;
      font-size: 8px;
      color: var(--text-muted);
      cursor: pointer;
    }

    .canvas-toggle input {
      accent-color: var(--accent-primary);
    }

    .canvas-wrapper {
      flex: 1;
      overflow: auto;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      /* ä¿®å¤ï¼šä»å·¦å¯¹é½ï¼Œé˜²æ­¢è¶…å®½ç”»å¸ƒæ—¶Yè½´è¢«æ¨å‡ºå¯è§†åŒº */
      min-height: 0;
      position: relative;
    }

    #mainCanvas {
      background: var(--canvas-bg);
      border-radius: 5px;
      display: block;
      cursor: default;
      transition: background 0.3s;
      transform-origin: center center;
    }

    .legend {
      background: var(--bg-card);
      border-radius: 4px;
      border: 1px solid var(--border-color);
      padding: 5px 8px;
      margin-top: 6px;
      flex-shrink: 0;
    }

    .legend-content {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 6px;
      font-size: 8px;
    }

    .legend-label {
      color: var(--text-dim);
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 2px;
      color: var(--text-muted);
    }

    .legend-color {
      width: 7px;
      height: 7px;
      border-radius: 1px;
    }

    .legend-divider {
      width: 1px;
      height: 8px;
      background: var(--border-color);
    }

    .context-menu {
      position: fixed;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      padding: 3px 0;
      min-width: 120px;
      box-shadow: 0 6px 24px rgba(0, 0, 0, 0.4);
      z-index: 1000;
      display: none;
    }

    .context-menu.show {
      display: block;
    }

    .context-menu-item {
      padding: 5px 9px;
      font-size: 9px;
      color: var(--text-secondary);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .context-menu-item:hover {
      background: rgba(99, 102, 241, 0.2);
    }

    .context-menu-item.danger {
      color: #f87171;
    }

    .context-menu-item.danger:hover {
      background: rgba(239, 68, 68, 0.2);
    }

    .context-menu-divider {
      height: 1px;
      background: var(--border-color);
      margin: 2px 0;
    }

    .tooltip {
      position: fixed;
      background: var(--bg-primary);
      border: 1px solid var(--accent-primary);
      border-radius: 3px;
      padding: 4px 7px;
      font-size: 8px;
      color: var(--text-secondary);
      max-width: 320px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 500;
      pointer-events: none;
      display: none;
      box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
    }

    .tooltip.pinned {
      pointer-events: auto;
      resize: both;
      overflow: auto;
      min-width: 150px;
      min-height: 80px;
    }

    .tooltip.show {
      display: block;
    }

    .tooltip-close {
      position: absolute;
      top: 2px;
      right: 4px;
      font-size: 12px;
      cursor: pointer;
      color: var(--text-dim);
      display: none;
    }

    .tooltip.pinned .tooltip-close {
      display: block;
    }

    .tooltip-close:hover {
      color: var(--text-primary);
    }

    .tooltip-title {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 2px;
    }

    .tooltip-note p {
      margin-bottom: 4px;
      margin-top: 0;
    }

    .tooltip-note p:last-child {
      margin-bottom: 0;
    }

    .tooltip-note ul,
    .tooltip-note ol {
      margin-top: 2px;
      margin-bottom: 2px;
      padding-left: 15px;
    }

    .tooltip-note li {
      margin-bottom: 1px;
    }

    .tooltip-note li p {
      margin: 0 !important;
      margin-bottom: 0 !important;
      display: block;
    }

    .tooltip-note blockquote {
      margin: 4px 0;
      padding-left: 8px;
      border-left: 2px solid var(--text-muted);
      color: var(--text-dim);
    }

    /* Tooltip å±æ€§æ ·å¼ */
    .tooltip-attrs {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
      margin-top: 2px;
    }

    .tooltip-attr {
      padding: 1px 3px;
      border-radius: 2px;
      font-size: 7px;
      color: white;
    }

    .tooltip-note {
      margin-top: 3px;
      padding-top: 3px;
      border-top: 1px solid var(--border-color);
      color: var(--text-muted);
      font-style: italic;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .tooltip-note img {
      max-width: 100%;
      max-height: 150px;
      border-radius: 4px;
      margin-top: 4px;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .tooltip-note img:hover {
      transform: scale(1.02);
    }

    /* å›¾ç‰‡æ”¾å¤§æŸ¥çœ‹æ¨¡æ€æ¡† */
    .image-viewer-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      cursor: zoom-out;
    }

    .image-viewer-overlay.show {
      display: flex;
    }

    .image-viewer-overlay img {
      max-width: 90vw;
      max-height: 90vh;
      border-radius: 8px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 14px;
      min-width: 260px;
      max-width: 90vw;
    }

    .modal-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 10px;
    }

    .modal-input {
      width: 100%;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      padding: 7px 9px;
      color: var(--text-secondary);
      font-size: 10px;
      outline: none;
      margin-bottom: 7px;
    }

    .modal-input:focus {
      border-color: var(--accent-primary);
    }

    .modal-textarea {
      width: 100%;
      background: var(--bg-input);
      border: 1px solid var(--border-color);
      border-radius: 3px;
      padding: 7px 9px;
      color: var(--text-secondary);
      font-size: 10px;
      outline: none;
      resize: vertical;
      min-height: 50px;
      font-family: inherit;
      margin-bottom: 7px;
    }

    .import-mode-selector {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .import-mode-option {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      padding: 8px;
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .import-mode-option:hover {
      border-color: var(--accent-primary);
      background: var(--bg-tertiary);
    }

    .import-mode-option input[type="radio"] {
      margin-top: 2px;
      accent-color: var(--accent-primary);
    }

    .import-mode-option input[type="radio"]:checked+.import-mode-label {
      color: var(--text-primary);
    }

    .import-mode-label {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .import-mode-label strong {
      font-size: 10px;
      color: var(--text-secondary);
    }

    .import-mode-label small {
      font-size: 8px;
      color: var(--text-dim);
    }


    .modal-actions {
      display: flex;
      gap: 4px;
      justify-content: flex-end;
    }

    .connection-mode-indicator {
      position: fixed;
      top: 48px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 9px;
      color: white;
      display: none;
      z-index: 100;
      box-shadow: 0 3px 12px rgba(99, 102, 241, 0.4);
    }

    .connection-mode-indicator.show {
      display: block;
    }

    .empty-state {
      text-align: center;
      padding: 12px;
      color: var(--text-dim);
      font-size: 8px;
    }

    ::-webkit-scrollbar {
      width: 3px;
      height: 3px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 2px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-dim);
    }
  </style>
</head>

<body>
  <header class="header">
    <div class="header-left">
      <h1>ç”Ÿæ€ç³»ç»Ÿæ¼”åŒ–<span>v2.3</span></h1>
      <div class="auto-save-indicator" id="autoSaveIndicator">
        <span>â±</span>
        <span id="autoSaveText">è‡ªåŠ¨ä¿å­˜</span>
      </div>
    </div>
    <div class="header-actions">
      <button class="btn btn-icon" onclick="undo()" title="æ’¤é”€ (Ctrl+Z)">â†¶</button>
      <div class="zoom-controls" title="ç”»å¸ƒå°ºå¯¸">
        <span style="font-size:8px;color:var(--text-dim);margin-right:2px;">å°ºå¯¸</span>
        <input type="number" id="canvasWidthInput" class="canvas-size-input" value="800" min="400" max="4000" step="50"
          onchange="updateCanvasSize()" title="ç”»å¸ƒå®½åº¦">
        <span style="font-size:8px;color:var(--text-dim);">Ã—</span>
        <input type="number" id="canvasHeightInput" class="canvas-size-input" value="450" min="200" max="2000" step="50"
          onchange="updateCanvasSize()" title="ç”»å¸ƒé«˜åº¦">
        <button class="zoom-btn" onclick="autoFitCanvas()" title="è‡ªé€‚åº”å°ºå¯¸">â¤¢</button>
      </div>
      <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomOut()">âˆ’</button>
        <span class="zoom-value" id="zoomValue">100%</span>
        <button class="zoom-btn" onclick="zoomIn()">+</button>
        <button class="zoom-btn" onclick="zoomFit()" title="å¤ä½è§†å›¾">âŸ²</button>
      </div>
      <select class="project-selector" id="projectSelector" onchange="loadProject(this.value)">
        <option value="">é€‰æ‹©é¡¹ç›®...</option>
      </select>
      <button class="btn" onclick="showNewProjectModal()">+ æ–°å»º</button>
      <button class="btn" onclick="renameProject()">é‡å‘½å</button>
      <button class="btn" onclick="deleteCurrentProject()" style="color: #f87171;">åˆ é™¤</button>
      <button class="btn btn-primary" onclick="saveProject()">ä¿å­˜</button>
      <button class="btn" onclick="exportProject()">å¯¼å‡º</button>
      <button class="btn" onclick="showImportModal()">å¯¼å…¥</button>
      <input type="file" id="importFile" accept=".json" style="display:none" onchange="importProjectFromFile(event)">
      <label class="mode-toggle" onclick="toggleDarkMode()">
        <span id="modeIcon">ğŸŒ™</span>
        <span id="modeText">å¤œé—´</span>
      </label>
    </div>
  </header>

  <div class="main-container">
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-content">
        <nav class="tab-nav">
          <button class="tab-btn active" data-tab="singularity">æ ¸å¿ƒ</button>
          <button class="tab-btn" data-tab="invariants">ä¸åŠ¨ç‚¹</button>
          <button class="tab-btn" data-tab="entities">å…¬å¸</button>
          <button class="tab-btn" data-tab="attributes">å±æ€§</button>
          <button class="tab-btn" data-tab="layers">å±‚çº§</button>
          <button class="tab-btn" data-tab="phases">é˜¶æ®µ</button>
          <button class="tab-btn" data-tab="styles">æ ·å¼</button>
        </nav>

        <div class="tab-content">
          <!-- åŸçˆ†ç‚¹é¢æ¿ -->
          <div id="singularity-panel" class="tab-panel active">
            <div class="singularity-card">
              <div class="section-title">ç”Ÿæ€åç§°</div>
              <input type="text" class="singularity-input large" id="ecosystemName" placeholder="å¦‚ï¼šAIç”Ÿæ€ç³»ç»Ÿ"
                oninput="updateSingularity()">

              <div class="section-title" style="margin-top: 6px;">æ ¸å¿ƒè¦ç´ ï¼ˆSingularityï¼‰</div>
              <input type="text" class="singularity-input" id="singularityName" placeholder="å¦‚ï¼šå¤§è¯­è¨€æ¨¡å‹"
                oninput="updateSingularity()">

              <div class="section-title" style="margin-top: 6px;">æè¿°è¯´æ˜</div>
              <textarea class="singularity-textarea" id="singularityDesc" placeholder="æè¿°è¿™ä¸ªç”Ÿæ€çš„æ ¸å¿ƒé©±åŠ¨åŠ›..."
                oninput="updateSingularity()"></textarea>
            </div>

            <div class="tip-box">
              <p>ğŸ’¡ æ ¸å¿ƒè¦ç´ æ˜¯ç”Ÿæ€ç³»ç»Ÿè¯ç”Ÿçš„å…³é”®é©±åŠ¨åŠ›ï¼Œå®ƒæ¶ˆé™¤äº†æŸç§çº¦æŸï¼Œåˆ›é€ äº†æ–°çš„å¯èƒ½æ€§ç©ºé—´ã€‚</p>
            </div>
          </div>

          <!-- ä¸åŠ¨ç‚¹é¢æ¿ -->
          <div id="invariants-panel" class="tab-panel">
            <div class="add-section">
              <div class="section-title">ç‚¹å‡»ç¬¦å·æ·»åŠ ä¸åŠ¨ç‚¹</div>
              <div class="symbol-buttons" id="symbolButtons"></div>
            </div>
            <div class="section-title">å·²æ·»åŠ çš„ä¸åŠ¨ç‚¹</div>
            <div id="invariantsList"></div>
          </div>

          <!-- å…¬å¸é¢æ¿ -->
          <div id="entities-panel" class="tab-panel">
            <div class="add-section">
              <button class="add-btn" onclick="addEntity()">+ æ·»åŠ æ–°å…¬å¸/è½½ä½“</button>
            </div>
            <div class="section-title">å·²æ·»åŠ çš„å…¬å¸</div>
            <div id="entitiesList"></div>
          </div>

          <!-- å±æ€§é¢æ¿ -->
          <div id="attributes-panel" class="tab-panel">
            <div class="add-section">
              <button class="add-btn add-btn-secondary" onclick="addAttributeType()">+ æ·»åŠ æ–°å±æ€§ç±»å‹</button>
            </div>
            <div id="attributesList"></div>
          </div>

          <!-- å±‚çº§é¢æ¿ -->
          <div id="layers-panel" class="tab-panel">
            <div class="add-section">
              <button class="add-btn add-btn-secondary" onclick="addLayer()">+ æ·»åŠ æ–°å±‚çº§</button>
            </div>
            <div id="layersList"></div>
            <div class="tip-box">
              <p>ğŸ’¡ è°ƒæ•´"é«˜åº¦æƒé‡"å¯æ”¹å˜å±‚çº§åœ¨ç”»å¸ƒä¸Šçš„å æ¯”å¤§å°</p>
            </div>
          </div>

          <!-- é˜¶æ®µé¢æ¿ -->
          <div id="phases-panel" class="tab-panel">
            <div class="add-section">
              <button class="add-btn add-btn-secondary" onclick="addPhase()">+ æ·»åŠ æ–°é˜¶æ®µ</button>
            </div>
            <div id="phasesList"></div>
          </div>

          <!-- æ ·å¼è®¾ç½®é¢æ¿ -->
          <div id="styles-panel" class="tab-panel">
            <div class="style-section">
              <div class="style-section-title">ä¸åŠ¨ç‚¹æ ·å¼</div>
              <div class="style-row">
                <span class="style-label">å›¾æ ‡å¤§å°</span>
                <div class="style-control">
                  <input type="range" class="style-range" min="8" max="30" value="16" id="invariantSize"
                    oninput="updateStyle('invariantSize', this.value)">
                  <span class="style-unit" id="invariantSizeValue">16</span>
                </div>
              </div>
              <div class="style-row">
                <span class="style-label">æ–‡å­—å¤§å°</span>
                <div class="style-control">
                  <input type="range" class="style-range" min="6" max="14" value="8" id="invariantFontSize"
                    oninput="updateStyle('invariantFontSize', this.value)">
                  <span class="style-unit" id="invariantFontSizeValue">8</span>
                </div>
              </div>
            </div>

            <div class="style-section">
              <div class="style-section-title">å…¬å¸æ ·å¼</div>
              <div class="style-row">
                <span class="style-label">å›¾æ ‡å®½åº¦</span>
                <div class="style-control">
                  <input type="range" class="style-range" min="40" max="120" value="70" id="entityWidth"
                    oninput="updateStyle('entityWidth', this.value)">
                  <span class="style-unit" id="entityWidthValue">70</span>
                </div>
              </div>
              <div class="style-row">
                <span class="style-label">å›¾æ ‡é«˜åº¦</span>
                <div class="style-control">
                  <input type="range" class="style-range" min="16" max="50" value="26" id="entityHeight"
                    oninput="updateStyle('entityHeight', this.value)">
                  <span class="style-unit" id="entityHeightValue">26</span>
                </div>
              </div>
              <div class="style-row">
                <span class="style-label">å­—ä½“å¤§å°</span>
                <div class="style-control">
                  <input type="range" class="style-range" min="6" max="14" value="9" id="entityFontSize"
                    oninput="updateStyle('entityFontSize', this.value)">
                  <span class="style-unit" id="entityFontSizeValue">9</span>
                </div>
              </div>
              <div class="style-row">
                <span class="style-label">å­—ä½“é¢œè‰²</span>
                <div class="style-control">
                  <input type="color" class="color-picker" value="#ffffff" id="entityFontColor"
                    onchange="updateStyle('entityFontColor', this.value)">
                </div>
              </div>
            </div>

            <div class="style-section">
              <div class="style-section-title">è¿çº¿æ ·å¼</div>
              <div class="style-row">
                <span class="style-label">æ™®é€šçº¿å®½</span>
                <div class="style-control">
                  <input type="range" class="style-range" min="1" max="5" value="2" id="connectionWidth"
                    oninput="updateStyle('connectionWidth', this.value)">
                  <span class="style-unit" id="connectionWidthValue">2</span>
                </div>
              </div>
              <div class="style-row">
                <span class="style-label">é«˜äº®çº¿å®½</span>
                <div class="style-control">
                  <input type="range" class="style-range" min="2" max="8" value="4" id="highlightWidth"
                    oninput="updateStyle('highlightWidth', this.value)">
                  <span class="style-unit" id="highlightWidthValue">4</span>
                </div>
              </div>
              <div class="style-row">
                <span class="style-label">é«˜äº®å‘å…‰</span>
                <div class="style-control">
                  <input type="range" class="style-range" min="0" max="20" value="8" id="highlightGlow"
                    oninput="updateStyle('highlightGlow', this.value)">
                  <span class="style-unit" id="highlightGlowValue">8</span>
                </div>
              </div>
            </div>

            <div class="style-section">
              <div class="style-section-title">ç•Œé¢è®¾ç½®</div>
              <div class="style-row">
                <span class="style-label">ç•Œé¢å­—ä½“ç¼©æ”¾</span>
                <div class="style-control">
                  <input type="range" class="style-range" min="80" max="150" value="100" id="uiFontScale"
                    oninput="updateUIFontScale(this.value)">
                  <span class="style-unit" id="uiFontScaleValue">100%</span>
                </div>
              </div>
              <div class="style-row">
                <span class="style-label">æ˜¾ç¤ºæ‚¬åœæ³¨é‡Š</span>
                <div class="style-control">
                  <input type="checkbox" id="showTooltips" checked onchange="updateStyle('showTooltips', this.checked)">
                </div>
              </div>
              <div class="style-row">
                <span class="style-label">æ³¨é‡Šå­—ä½“å¤§å°</span>
                <div class="style-control">
                  <input type="range" class="style-range" min="7" max="14" value="8" id="tooltipFontSize"
                    oninput="updateStyle('tooltipFontSize', this.value)">
                  <span class="style-unit" id="tooltipFontSizeValue">8</span>
                </div>
              </div>
            </div>

            <div class="style-section">
              <div class="style-section-title">é¢„è®¾é…è‰²æ–¹æ¡ˆ</div>
              <div id="colorSchemePreview"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="sidebar-resizer" id="sidebarResizer"></div>
    </aside>

    <button class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()">
      <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="15 18 9 12 15 6" />
      </svg>
    </button>

    <main class="canvas-area">
      <div class="canvas-container">
        <div class="canvas-toolbar">
          <span class="canvas-hint">æ‹–æ‹½ç§»åŠ¨å…ƒç´  â€¢ ç©ºæ ¼+æ‹–æ‹½å¹³ç§»ç”»å¸ƒ â€¢ å³é”®èœå• â€¢ Ctrl+æ»šè½®ç¼©æ”¾</span>
          <label class="canvas-toggle">
            <input type="checkbox" id="showCurvePoints" checked
              onchange="state.showCurvePoints = this.checked; render()">
            æ˜¾ç¤ºæ›²çº¿æ§åˆ¶ç‚¹
          </label>
        </div>
        <div class="canvas-wrapper" id="canvasWrapper">
          <canvas id="mainCanvas"></canvas>
        </div>
      </div>

      <div class="legend">
        <div class="legend-content" id="legendContent"></div>
      </div>
    </main>
  </div>

  <div class="context-menu" id="contextMenu">
    <div class="context-menu-item" id="copyMenuItem" onclick="contextMenuAction('copy')">ğŸ“‹ å¤åˆ¶</div>
    <div class="context-menu-item" onclick="contextMenuAction('addNote')">ğŸ“ ç¼–è¾‘æ³¨é‡Š</div>
    <div class="context-menu-item" id="connectMenuItem" onclick="contextMenuAction('startConnect')">ğŸ”— å¼€å§‹è¿çº¿</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item danger" onclick="contextMenuAction('delete')">ğŸ—‘ï¸ åˆ é™¤</div>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <div class="connection-mode-indicator" id="connectionModeIndicator">
    ğŸ”— è¿çº¿æ¨¡å¼ï¼šç‚¹å‡»ç›®æ ‡å®Œæˆè¿çº¿ï¼ŒESCå–æ¶ˆ
  </div>

  <!-- å›¾ç‰‡æ”¾å¤§æŸ¥çœ‹å™¨ -->
  <div class="image-viewer-overlay" id="imageViewerOverlay" onclick="closeImageViewer()">
    <img id="imageViewerImg" src="" alt="æ”¾å¤§æŸ¥çœ‹">
  </div>

  <div class="modal-overlay" id="newProjectModal">
    <div class="modal">
      <div class="modal-title">æ–°å»ºé¡¹ç›®</div>
      <input type="text" class="modal-input" id="newProjectName" placeholder="é¡¹ç›®åç§°">
      <div class="modal-actions">
        <button class="btn" onclick="closeModal('newProjectModal')">å–æ¶ˆ</button>
        <button class="btn btn-primary" onclick="createNewProject()">åˆ›å»º</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="noteModal">
    <div class="modal" style="min-width: 320px;">
      <div class="modal-title">ç¼–è¾‘æ³¨é‡Š</div>
      <textarea class="modal-textarea" id="noteContent" placeholder="è¾“å…¥æ³¨é‡Šå†…å®¹..."></textarea>
      <div style="margin-bottom: 7px;">
        <div style="font-size: 9px; color: var(--text-muted); margin-bottom: 4px;">ğŸ“· ç²˜è´´å›¾ç‰‡ï¼ˆCtrl+Vï¼‰æˆ–ç‚¹å‡»æ·»åŠ ï¼ˆå¯æ·»åŠ å¤šå¼ ï¼‰ï¼š</div>
        <div id="noteImagesContainer" style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 6px;"></div>
        <div id="noteImageDropZone"
          style="border: 2px dashed var(--border-color); border-radius: 4px; padding: 8px; text-align: center; cursor: pointer; transition: all 0.2s;"
          onclick="document.getElementById('noteImageInput').click();">
          <div style="font-size: 9px; color: var(--text-dim);">+ ç‚¹å‡»æ·»åŠ å›¾ç‰‡</div>
        </div>
        <input type="file" id="noteImageInput" accept="image/*" style="display: none;"
          onchange="handleNoteImageSelect(event)" multiple>
      </div>
      <div class="modal-actions">
        <button class="btn" onclick="closeModal('noteModal')">å–æ¶ˆ</button>
        <button class="btn btn-primary" onclick="saveNote()">ä¿å­˜</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="importModal">
    <div class="modal" style="min-width: 360px;">
      <div class="modal-title">å¯¼å…¥ JSON æ•°æ®</div>

      <!-- å¯¼å…¥æ¨¡å¼é€‰æ‹© -->
      <div style="margin-bottom: 10px;">
        <div style="font-size: 9px; color: var(--text-muted); margin-bottom: 6px;">å¯¼å…¥æ¨¡å¼ï¼š</div>
        <div class="import-mode-selector">
          <label class="import-mode-option">
            <input type="radio" name="importMode" value="new" checked>
            <span class="import-mode-label">
              <strong>ğŸ†• æ–°å»ºé¡¹ç›®</strong>
              <small>åˆ›å»ºæ–°é¡¹ç›®ï¼Œå®Œå…¨æ›¿æ¢</small>
            </span>
          </label>
          <label class="import-mode-option">
            <input type="radio" name="importMode" value="merge">
            <span class="import-mode-label">
              <strong>â• è¡¥å……åˆ°å½“å‰é¡¹ç›®</strong>
              <small>ä¿ç•™ç°æœ‰å†…å®¹ï¼Œè¿½åŠ æ–°å…ƒç´ </small>
            </span>
          </label>
        </div>
      </div>

      <div style="margin-bottom: 10px;">
        <button class="btn" style="width: 100%; margin-bottom: 6px;" onclick="triggerFileImport()">
          ğŸ“ ä»æ–‡ä»¶å¯¼å…¥ JSON
        </button>
        <div style="text-align: center; font-size: 9px; color: var(--text-dim); margin: 6px 0;">â”€â”€ æˆ–è€… â”€â”€</div>
        <div style="font-size: 9px; color: var(--text-muted); margin-bottom: 4px;">ç²˜è´´ JSON å†…å®¹ï¼š</div>
        <textarea class="modal-textarea" id="importJsonText" placeholder="ç²˜è´´ JSON å†…å®¹..."
          style="min-height: 120px; font-family: monospace; font-size: 9px;"></textarea>
      </div>
      <div class="modal-actions">
        <button class="btn" onclick="closeModal('importModal')">å–æ¶ˆ</button>
        <button class="btn btn-primary" onclick="importProjectFromText()">å¯¼å…¥</button>
      </div>
    </div>
  </div>

  <script>
    // ========== é¢„è®¾é…è‰²æ–¹æ¡ˆ ==========
    const colorSchemes = {
      'æ´»åŠ›': ['#EF4444', '#F97316', '#FBBF24', '#84CC16', '#10B981', '#06B6D4', '#3B82F6', '#8B5CF6', '#EC4899'],
      'æŸ”å’Œ': ['#FDA4AF', '#FDBA74', '#FDE047', '#BEF264', '#6EE7B7', '#67E8F9', '#93C5FD', '#C4B5FD', '#F9A8D4'],
      'ä¸“ä¸š': ['#1E40AF', '#1D4ED8', '#2563EB', '#3B82F6', '#60A5FA', '#0EA5E9', '#14B8A6', '#10B981', '#059669'],
      'æš—è‰²': ['#7C3AED', '#6366F1', '#4F46E5', '#4338CA', '#3730A3', '#312E81', '#581C87', '#831843', '#9F1239'],
      'è‡ªç„¶': ['#365314', '#3F6212', '#4D7C0F', '#65A30D', '#84CC16', '#A3E635', '#BEF264', '#D9F99D', '#ECFCCB'],
      'ç§‘æŠ€': ['#0F172A', '#1E293B', '#334155', '#475569', '#64748B', '#94A3B8', '#CBD5E1', '#E2E8F0', '#F1F5F9']
    };

    const schemeKeys = Object.keys(colorSchemes);




    // ========== æ•°æ®æ¨¡å‹ ==========
    let state = {
      projectId: null,
      projectName: 'æœªå‘½åé¡¹ç›®',
      ecosystemName: '',
      singularityName: '',
      singularityDesc: '',
      phases: [],
      valueLayers: [],
      attributeTypes: [],
      invariantTypes: [
        { id: 'triangle', symbol: 'â–³', name: 'ä¸‰è§’å½¢', color: '#F97316' },
        { id: 'circle', symbol: 'â—‹', name: 'åœ†å½¢', color: '#8B5CF6' },
        { id: 'square', symbol: 'â–¡', name: 'æ­£æ–¹å½¢', color: '#06B6D4' },
        { id: 'cross', symbol: 'Ã—', name: 'å‰å½¢', color: '#EF4444' },
        { id: 'diamond', symbol: 'â—‡', name: 'è±å½¢', color: '#84CC16' },
      ],
      invariants: [],
      entities: [],
      connections: [],
      curvePoints: [],
      selectedItem: null,
      showCurvePoints: true,
      draggedItem: null,
      zoom: 1,
      styles: {
        invariantSize: 16,
        invariantFontSize: 8,
        entityWidth: 70,
        entityHeight: 26,
        entityFontSize: 9,
        entityFontColor: '#ffffff',
        connectionWidth: 2,
        highlightWidth: 4,
        highlightGlow: 8,
        uiFontScale: 100,
        showTooltips: true,
        tooltipFontSize: 8
      },
      darkMode: true
    };

    let contextTarget = null;
    let connectionMode = { active: false, source: null };
    let sidebarWidth = 240;
    let undoStack = [];
    const MAX_UNDO = 50;
    let autoSaveTimer = null;

    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    let padding = { left: 70, right: 25, top: 50, bottom: 60 };
    let baseCanvasWidth = 800;
    let baseCanvasHeight = 450;

    // ========== ç”»å¸ƒå¹³ç§»çŠ¶æ€ ==========
    let panState = {
      panX: 0,
      panY: 0,
      isPanning: false,
      startX: 0,
      startY: 0,
      spacePressed: false
    };

    // ========== ç¼©æ”¾åŠŸèƒ½ ==========
    function zoomIn() {
      state.zoom = Math.min(2, state.zoom + 0.1);
      applyZoom();
    }

    function zoomOut() {
      state.zoom = Math.max(0.3, state.zoom - 0.1);
      applyZoom();
    }

    function zoomReset() {
      state.zoom = 1;
      applyZoom();
    }

    function applyZoom() {
      document.getElementById('zoomValue').textContent = Math.round(state.zoom * 100) + '%';
      // ä¸å†ä½¿ç”¨ CSS transformï¼Œè€Œæ˜¯åœ¨ render ä¸­ä½¿ç”¨ ctx.scale
      render();
    }

    function resetPan() {
      panState.panX = 0;
      panState.panY = 0;
      render();
    }

    function zoomFit() {
      // é‡ç½®å¹³ç§»å’Œç¼©æ”¾åˆ°åˆå§‹çŠ¶æ€
      panState.panX = 0;
      panState.panY = 0;
      state.zoom = 1;
      applyZoom();
    }

    // æ»šè½®ç¼©æ”¾
    document.getElementById('canvasWrapper').addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        if (e.deltaY < 0) zoomIn();
        else zoomOut();
      }
    }, { passive: false });

    // ========== æ’¤é”€åŠŸèƒ½ ==========
    function saveStateForUndo() {
      const stateCopy = JSON.parse(JSON.stringify({
        invariants: state.invariants,
        entities: state.entities,
        connections: state.connections,
        curvePoints: state.curvePoints,
        phases: state.phases,
        valueLayers: state.valueLayers,
        attributeTypes: state.attributeTypes
      }));
      undoStack.push(stateCopy);
      if (undoStack.length > MAX_UNDO) undoStack.shift();
    }

    function undo() {
      if (undoStack.length === 0) return;
      const prevState = undoStack.pop();
      Object.assign(state, prevState);
      renderAll();
    }

    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        undo();
      }
      if (e.key === 'Escape' && connectionMode.active) {
        connectionMode = { active: false, source: null };
        document.getElementById('connectionModeIndicator').classList.remove('show');
      }
      // ç©ºæ ¼é”®æ¿€æ´»å¹³ç§»æ¨¡å¼
      if (e.code === 'Space' && !e.repeat) {
        // å¦‚æœæ­£åœ¨è¾“å…¥æ–‡å­—ï¼Œä¸è§¦å‘å¹³ç§»
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        e.preventDefault();
        panState.spacePressed = true;
        canvas.style.cursor = 'grab';
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.code === 'Space') {
        panState.spacePressed = false;
        panState.isPanning = false;
        canvas.style.cursor = 'default';
      }
    });

    // ========== è‡ªåŠ¨ä¿å­˜ ==========
    function startAutoSave() {
      if (autoSaveTimer) clearInterval(autoSaveTimer);
      autoSaveTimer = setInterval(() => {
        if (state.projectId) {
          const indicator = document.getElementById('autoSaveIndicator');
          const text = document.getElementById('autoSaveText');
          indicator.classList.add('saving');
          text.textContent = 'ä¿å­˜ä¸­...';
          saveProject(true);
          setTimeout(() => {
            indicator.classList.remove('saving');
            text.textContent = 'å·²ä¿å­˜';
            setTimeout(() => { text.textContent = 'è‡ªåŠ¨ä¿å­˜'; }, 2000);
          }, 500);
        }
      }, 60000);
    }

    // ========== æ·±è‰²/æµ…è‰²æ¨¡å¼ ==========
    function toggleDarkMode() {
      state.darkMode = !state.darkMode;
      applyDarkMode();
    }

    function applyDarkMode() {
      if (state.darkMode) {
        document.body.classList.remove('light-mode');
        document.getElementById('modeIcon').textContent = 'ğŸŒ™';
        document.getElementById('modeText').textContent = 'å¤œé—´';
      } else {
        document.body.classList.add('light-mode');
        document.getElementById('modeIcon').textContent = 'â˜€ï¸';
        document.getElementById('modeText').textContent = 'æ—¥é—´';
      }
      render();
    }

    // ========== é»˜è®¤é…ç½® ==========
    function getDefaultPhases() {
      return [
        { id: 1, name: 'èŒèŠ½æœŸ', startYear: 2020, endYear: 2022, proximity: '0-5%', task: 'è¯æ˜å¯è¡Œæ€§' },
        { id: 2, name: 'æ¢ç´¢æœŸ', startYear: 2022, endYear: 2024, proximity: '5-20%', task: 'æ‰¾åˆ°ç”¨æˆ·' },
        { id: 3, name: 'æˆé•¿æœŸ', startYear: 2024, endYear: 2026, proximity: '20-40%', task: 'å•†ä¸šåŒ–' },
      ];
    }

    function getDefaultLayers() {
      return [
        { id: 1, name: 'è¦ç´ å±‚', color: '#10B981', description: 'è°å„æ–­äº†æºå¤´ï¼Ÿ', visiblePhases: [1, 2, 3], heightWeight: 1 },
        { id: 2, name: 'åŸºç¡€è®¾æ–½å±‚', color: '#F59E0B', description: 'è°æŒæ¡äº†æ¸ é“ï¼Ÿ', visiblePhases: [1, 2, 3], heightWeight: 1 },
        { id: 3, name: 'åœºæ™¯ä¸å…¥å£å±‚', color: '#EC4899', description: 'è°æ§åˆ¶äº†å…¥å£ï¼Ÿ', visiblePhases: [2, 3], heightWeight: 1 },
        { id: 4, name: 'è§„åˆ™ä¸æ ‡å‡†å±‚', color: '#3B82F6', description: 'è°å®šä¹‰äº†è§„åˆ™ï¼Ÿ', visiblePhases: [3], heightWeight: 1 },
      ];
    }

    function getDefaultAttributes() {
      return [
        { id: 'element', name: 'è¦ç´ ', color: '#10B981' },
        { id: 'infrastructure', name: 'åŸºç¡€è®¾æ–½', color: '#F59E0B' },
        { id: 'scene', name: 'åœºæ™¯', color: '#EC4899' },
        { id: 'entrance', name: 'å…¥å£', color: '#A855F7' },
        { id: 'rulemaker', name: 'è§„åˆ™åˆ¶å®šè€…', color: '#3B82F6' },
      ];
    }

    function getDefaultStyles() {
      return {
        invariantSize: 16,
        invariantFontSize: 8,
        entityWidth: 70,
        entityHeight: 26,
        entityFontSize: 9,
        entityFontColor: '#ffffff',
        connectionWidth: 2,
        highlightWidth: 4,
        highlightGlow: 8,
        uiFontScale: 100,
        showTooltips: true,
        tooltipFontSize: 8
      };
    }

    // ========== æ›²çº¿ç”Ÿæˆ ==========
    function generateSpiralCurve(phaseCount) {
      const points = [];
      const cw = baseCanvasWidth - padding.left - padding.right;
      const ch = baseCanvasHeight - padding.top - padding.bottom;
      const ppp = 4;
      const total = phaseCount * ppp + 1;

      for (let i = 0; i <= total; i++) {
        const p = i / total;
        const x = p * cw;
        const baseY = ch - (p * ch * 0.85);
        const amp = 30 + (1 - p) * 20;
        const wave = -amp * Math.sin((i % ppp) / ppp * 2 * Math.PI);
        const y = padding.top + baseY + wave;
        points.push({ x, y: Math.max(padding.top + 10, Math.min(baseCanvasHeight - padding.bottom - 10, y)), note: '' });
      }
      return points;
    }

    function extendCurveForNewPhase() {
      if (state.curvePoints.length === 0) return;
      const last = state.curvePoints[state.curvePoints.length - 1];
      const cw = baseCanvasWidth - padding.left - padding.right;
      const phaseWidth = cw / state.phases.length;

      for (let i = 1; i <= 4; i++) {
        const p = i / 4;
        const newX = last.x + p * phaseWidth;
        const rise = 25 * p;
        const wave = 20 * Math.sin(p * 2 * Math.PI);
        const newY = Math.max(padding.top + 10, last.y - rise + wave);
        state.curvePoints.push({ x: newX, y: newY, note: '' });
      }
    }

    // ========== å·¥å…·å‡½æ•° ==========
    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
    }

    function hexToRgba(hex, alpha) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // ========== æ ·å¼æ›´æ–° ==========
    // ä¿å­˜æ ·å¼åˆ° LocalStorage
    function saveStylesToLocal() {
      try {
        localStorage.setItem('ecosystemStyles', JSON.stringify(state.styles));
      } catch (e) {
        console.warn('ä¿å­˜æ ·å¼å¤±è´¥:', e);
      }
    }

    // ä» LocalStorage åŠ è½½æ ·å¼
    function loadStylesFromLocal() {
      try {
        const saved = localStorage.getItem('ecosystemStyles');
        if (saved) {
          const savedStyles = JSON.parse(saved);
          // åˆå¹¶åˆ°é»˜è®¤æ ·å¼ï¼Œç¡®ä¿æ–°å¢çš„æ ·å¼å±æ€§ä¸ä¼šç¼ºå¤±
          return { ...getDefaultStyles(), ...savedStyles };
        }
      } catch (e) {
        console.warn('åŠ è½½æ ·å¼å¤±è´¥:', e);
      }
      return getDefaultStyles();
    }

    function updateStyle(key, value) {
      state.styles[key] = isNaN(value) ? value : parseFloat(value);
      const el = document.getElementById(key + 'Value');
      if (el) el.textContent = value;
      saveStylesToLocal();
      render();
    }

    function applyStyles() {
      const s = state.styles;
      ['invariantSize', 'invariantFontSize', 'entityWidth', 'entityHeight', 'entityFontSize', 'connectionWidth', 'highlightWidth', 'highlightGlow', 'tooltipFontSize'].forEach(k => {
        const input = document.getElementById(k);
        const val = document.getElementById(k + 'Value');
        if (input) input.value = s[k];
        if (val) val.textContent = s[k];
      });
      const fontColor = document.getElementById('entityFontColor');
      if (fontColor) fontColor.value = s.entityFontColor;
      // UIå­—ä½“ç¼©æ”¾
      const uiScale = document.getElementById('uiFontScale');
      const uiScaleVal = document.getElementById('uiFontScaleValue');
      if (uiScale) uiScale.value = s.uiFontScale || 100;
      if (uiScaleVal) uiScaleVal.textContent = (s.uiFontScale || 100) + '%';
      applyUIFontScale(s.uiFontScale || 100);
      // æ³¨é‡Šæ˜¾ç¤ºå¼€å…³
      const showTooltips = document.getElementById('showTooltips');
      if (showTooltips) showTooltips.checked = s.showTooltips !== false;
    }

    function updateUIFontScale(value) {
      state.styles.uiFontScale = parseInt(value);
      document.getElementById('uiFontScaleValue').textContent = value + '%';
      saveStylesToLocal();
      applyUIFontScale(value);
    }

    function updateShowTooltips(checked) {
      state.styles.showTooltips = checked;
      saveStylesToLocal();
    }

    function applyUIFontScale(scale) {
      const scaleValue = scale / 100;
      // ä½¿ç”¨CSSå˜é‡å’Œtransformç¼©æ”¾ä¾§è¾¹æ å’Œheader
      const sidebar = document.querySelector('.sidebar-content');
      const header = document.querySelector('.header');
      const tabContent = document.querySelector('.tab-content');

      if (sidebar) {
        sidebar.style.transform = `scale(${scaleValue})`;
        sidebar.style.transformOrigin = 'top left';
        sidebar.style.width = (100 / scaleValue) + '%';
        sidebar.style.height = (100 / scaleValue) + '%';
      }
      // è°ƒæ•´ä¾§è¾¹æ å®½åº¦ä»¥é€‚åº”ç¼©æ”¾
      const sidebarEl = document.querySelector('.sidebar');
      if (sidebarEl && !sidebarEl.classList.contains('collapsed')) {
        const baseWidth = 240;
        sidebarEl.style.width = (baseWidth * scaleValue) + 'px';
      }
    }

    // ========== è°ƒæ•´ç”»å¸ƒå¤§å° ==========
    // ç”¨æˆ·è‡ªå®šä¹‰ç”»å¸ƒå°ºå¯¸æ¨¡å¼ï¼ˆfalseè¡¨ç¤ºè‡ªé€‚åº”çª—å£ï¼Œtrueè¡¨ç¤ºä½¿ç”¨ç”¨æˆ·è®¾ç½®çš„å°ºå¯¸ï¼‰
    let customCanvasMode = false;
    let customCanvasWidth = 800;
    let customCanvasHeight = 450;

    // ä¿å­˜ç”»å¸ƒå°ºå¯¸åˆ° LocalStorage
    function saveCanvasSizeToLocal() {
      try {
        localStorage.setItem('ecosystemCanvasSize', JSON.stringify({
          customMode: customCanvasMode,
          width: customCanvasWidth,
          height: customCanvasHeight
        }));
      } catch (e) {
        console.warn('ä¿å­˜ç”»å¸ƒå°ºå¯¸å¤±è´¥:', e);
      }
    }

    // ä» LocalStorage åŠ è½½ç”»å¸ƒå°ºå¯¸
    function loadCanvasSizeFromLocal() {
      try {
        const saved = localStorage.getItem('ecosystemCanvasSize');
        if (saved) {
          const data = JSON.parse(saved);
          customCanvasMode = data.customMode || false;
          customCanvasWidth = data.width || 800;
          customCanvasHeight = data.height || 450;
        }
      } catch (e) {
        console.warn('åŠ è½½ç”»å¸ƒå°ºå¯¸å¤±è´¥:', e);
      }
    }

    // æ›´æ–°ç”»å¸ƒå°ºå¯¸è¾“å…¥æ¡†çš„æ˜¾ç¤ºå€¼
    function updateCanvasSizeInputs() {
      const widthInput = document.getElementById('canvasWidthInput');
      const heightInput = document.getElementById('canvasHeightInput');
      if (widthInput) widthInput.value = baseCanvasWidth;
      if (heightInput) heightInput.value = baseCanvasHeight;
    }

    // ç”¨æˆ·æ‰‹åŠ¨è®¾ç½®ç”»å¸ƒå°ºå¯¸
    function updateCanvasSize() {
      const widthInput = document.getElementById('canvasWidthInput');
      const heightInput = document.getElementById('canvasHeightInput');
      const newWidth = parseInt(widthInput.value) || 800;
      const newHeight = parseInt(heightInput.value) || 450;

      customCanvasMode = true;
      customCanvasWidth = Math.max(400, Math.min(4000, newWidth));
      customCanvasHeight = Math.max(200, Math.min(2000, newHeight));

      baseCanvasWidth = customCanvasWidth;
      baseCanvasHeight = customCanvasHeight;
      canvas.width = baseCanvasWidth;
      canvas.height = baseCanvasHeight;

      updateCanvasSizeInputs();
      saveCanvasSizeToLocal();
      render();
    }

    // è‡ªé€‚åº”çª—å£å°ºå¯¸
    function autoFitCanvas() {
      customCanvasMode = false;
      const wrapper = document.querySelector('.canvas-wrapper');
      baseCanvasWidth = Math.max(600, wrapper.clientWidth - 16);
      baseCanvasHeight = Math.max(300, wrapper.clientHeight - 16);
      canvas.width = baseCanvasWidth;
      canvas.height = baseCanvasHeight;

      updateCanvasSizeInputs();
      saveCanvasSizeToLocal();
      render();
    }

    // æ ¹æ®æ•°æ®è‡ªåŠ¨æ‰©å±•ç”»å¸ƒä»¥å®¹çº³æ‰€æœ‰å…ƒç´ 
    function autoExpandCanvasForData() {
      let maxX = 0;
      let maxY = 0;

      // æ£€æŸ¥æ‰€æœ‰ä¸åŠ¨ç‚¹çš„ä½ç½®
      state.invariants.forEach(inv => {
        maxX = Math.max(maxX, inv.x + 50);
        maxY = Math.max(maxY, inv.y + 50);
      });

      // æ£€æŸ¥æ‰€æœ‰å…¬å¸çš„ä½ç½®
      state.entities.forEach(ent => {
        maxX = Math.max(maxX, ent.x + state.styles.entityWidth / 2 + 20);
        maxY = Math.max(maxY, ent.y + state.styles.entityHeight / 2 + 20);
      });

      // æ£€æŸ¥æ›²çº¿æ§åˆ¶ç‚¹
      state.curvePoints.forEach(pt => {
        maxX = Math.max(maxX, pt.x + padding.left + 50);
        maxY = Math.max(maxY, pt.y + 50);
      });

      // å¦‚æœæ•°æ®è¶…å‡ºå½“å‰ç”»å¸ƒèŒƒå›´ï¼Œæ‰©å±•ç”»å¸ƒ
      const needsExpand = maxX > baseCanvasWidth || maxY > baseCanvasHeight;
      if (needsExpand) {
        const newWidth = Math.max(baseCanvasWidth, Math.ceil(maxX / 50) * 50 + 50);
        const newHeight = Math.max(baseCanvasHeight, Math.ceil(maxY / 50) * 50 + 50);

        customCanvasMode = true;
        customCanvasWidth = newWidth;
        customCanvasHeight = newHeight;
        baseCanvasWidth = newWidth;
        baseCanvasHeight = newHeight;
        canvas.width = baseCanvasWidth;
        canvas.height = baseCanvasHeight;

        updateCanvasSizeInputs();
        saveCanvasSizeToLocal();
      }
    }

    function resizeCanvas() {
      if (customCanvasMode) {
        // ç”¨æˆ·è‡ªå®šä¹‰æ¨¡å¼ï¼šä½¿ç”¨ä¿å­˜çš„å°ºå¯¸
        baseCanvasWidth = customCanvasWidth;
        baseCanvasHeight = customCanvasHeight;
      } else {
        // è‡ªé€‚åº”æ¨¡å¼ï¼šæ ¹æ®çª—å£å¤§å°è°ƒæ•´
        const wrapper = document.querySelector('.canvas-wrapper');
        baseCanvasWidth = Math.max(600, wrapper.clientWidth - 16);
        baseCanvasHeight = Math.max(300, wrapper.clientHeight - 16);
      }
      canvas.width = baseCanvasWidth;
      canvas.height = baseCanvasHeight;
      updateCanvasSizeInputs();
      render();
    }


    // ========== è®¡ç®—å±‚çº§é«˜åº¦ ==========
    function getLayerHeights() {
      const visibleLayers = state.valueLayers.filter(l => l.visiblePhases && l.visiblePhases.length > 0);
      if (visibleLayers.length === 0) return [];

      const totalWeight = visibleLayers.reduce((sum, l) => sum + (l.heightWeight || 1), 0);
      const totalHeight = canvas.height - padding.top - padding.bottom;

      let currentY = padding.top;
      return visibleLayers.slice().reverse().map(layer => {
        const weight = layer.heightWeight || 1;
        const height = (weight / totalWeight) * totalHeight;
        const result = { layer, y: currentY, height };
        currentY += height;
        return result;
      });
    }

    // ========== æ™ºèƒ½åæ ‡è®¡ç®—ï¼ˆç”¨äºå¯¼å…¥æ—¶è‡ªåŠ¨å®šä½ï¼‰==========
    // æ ¹æ® layerId è®¡ç®—å…ƒç´ åº”è¯¥æ”¾ç½®çš„ Y åæ ‡ï¼ˆå±‚çº§ä¸­å¿ƒï¼‰
    // æ ¹æ® phaseIndex è®¡ç®—å…ƒç´ åº”è¯¥æ”¾ç½®çš„ X åæ ‡ï¼ˆé˜¶æ®µä¸­å¿ƒï¼‰
    function calculateSmartPosition(layerId, phaseIndex, phases, valueLayers, canvasWidth, canvasHeight) {
      // è®¡ç®— Y åæ ‡ï¼šåŸºäº layerId æ‰¾åˆ°å¯¹åº”å±‚çº§çš„ä¸­å¿ƒä½ç½®
      const validLayers = valueLayers.filter(l => l.visiblePhases && l.visiblePhases.length > 0);
      const totalWeight = validLayers.reduce((sum, l) => sum + (l.heightWeight || 1), 0);
      const totalHeight = canvasHeight - padding.top - padding.bottom;

      let y = canvasHeight / 2; // é»˜è®¤å€¼ï¼šç”»å¸ƒä¸­å¿ƒ
      let currentY = padding.top;

      // æŒ‰ç…§æ¸²æŸ“é¡ºåºï¼ˆä»ä¸Šåˆ°ä¸‹ï¼‰éå†å±‚çº§
      for (const layer of validLayers.slice().reverse()) {
        const weight = layer.heightWeight || 1;
        const height = (weight / totalWeight) * totalHeight;

        if (layer.id === layerId) {
          y = currentY + height / 2; // å±‚çº§ä¸­å¿ƒ
          break;
        }
        currentY += height;
      }

      // è®¡ç®— X åæ ‡ï¼šåŸºäº phaseIndex æ‰¾åˆ°å¯¹åº”é˜¶æ®µçš„ä¸­å¿ƒä½ç½®
      const phaseCount = phases.length || 1;
      const availableWidth = canvasWidth - padding.left - padding.right;
      const phaseWidth = availableWidth / phaseCount;

      // phaseIndex ä» 1 å¼€å§‹ï¼ˆå¯¹åº” phase.idï¼‰
      const safePhaseIndex = Math.max(1, Math.min(phaseIndex || 1, phaseCount));
      const x = padding.left + (safePhaseIndex - 0.5) * phaseWidth;

      return { x, y };
    }

    // ========== æ¸²æŸ“å‡½æ•° ==========
    function render() {
      const isDark = state.darkMode;

      // 1. æ¸…ç©ºå¹¶å¡«å……èƒŒæ™¯
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = isDark ? '#0f172a' : '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 2. ç»˜åˆ¶å†…å®¹åŒºåŸŸï¼ˆå—ç¼©æ”¾å’Œå¹³ç§»å½±å“ï¼‰
      ctx.save();

      // è£å‰ªåˆ°å†…å®¹åŒºåŸŸï¼Œé˜²æ­¢å†…å®¹æº¢å‡ºåˆ°åæ ‡è½´åŒºåŸŸ
      ctx.beginPath();
      ctx.rect(padding.left, padding.top,
        canvas.width - padding.left - padding.right,
        canvas.height - padding.top - padding.bottom);
      ctx.clip();

      // åº”ç”¨ç¼©æ”¾ï¼ˆä»¥ç”»å¸ƒä¸­å¿ƒä¸ºç¼©æ”¾åŸç‚¹ï¼‰
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      ctx.translate(centerX, centerY);
      ctx.scale(state.zoom, state.zoom);
      ctx.translate(-centerX, -centerY);
      // åº”ç”¨å¹³ç§»
      ctx.translate(panState.panX, panState.panY);

      // ç»˜åˆ¶æ‰€æœ‰å†…å®¹å…ƒç´ 
      drawGrid(isDark);
      drawLayerBackgrounds();
      drawPhaseDividers(isDark);  // åªç»˜åˆ¶åˆ†éš”çº¿ï¼Œæ ‡ç­¾åœ¨å¤–éƒ¨ç»˜åˆ¶
      drawCurve();
      if (state.showCurvePoints) drawCurveControlPoints();
      drawConnections();
      drawInvariants(isDark);
      drawEntities(isDark);

      ctx.restore();

      // 3. ç»˜åˆ¶å›ºå®šUIå…ƒç´ ï¼ˆä¸å—ç¼©æ”¾å¹³ç§»å½±å“ï¼Œå§‹ç»ˆå¯è§ï¼‰
      drawAxesBackground(isDark);  // èƒŒæ™¯é®ç›–å±‚
      drawAxes(isDark);            // åæ ‡è½´çº¿
      drawTitle(isDark);           // æ ‡é¢˜
      drawYAxisLabels();           // Yè½´æ ‡ç­¾
      drawXAxisLabels(isDark);     // Xè½´é˜¶æ®µæ ‡ç­¾
    }

    function drawGrid(isDark) {
      ctx.strokeStyle = isDark ? 'rgba(51, 65, 85, 0.3)' : 'rgba(148, 163, 184, 0.3)';
      ctx.lineWidth = 0.5;
      for (let x = padding.left; x < canvas.width - padding.right; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, padding.top);
        ctx.lineTo(x, canvas.height - padding.bottom);
        ctx.stroke();
      }
      for (let y = padding.top; y < canvas.height - padding.bottom; y += 40) {
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(canvas.width - padding.right, y);
        ctx.stroke();
      }
    }

    function drawTitle(isDark) {
      if (state.ecosystemName || state.singularityName) {
        ctx.textAlign = 'center';
        if (state.ecosystemName) {
          ctx.fillStyle = isDark ? '#f1f5f9' : '#0f172a';
          ctx.font = 'bold 13px -apple-system, sans-serif';
          ctx.fillText(state.ecosystemName, canvas.width / 2, 18);
        }
        if (state.singularityName) {
          ctx.fillStyle = '#8b5cf6';
          ctx.font = '9px -apple-system, sans-serif';
          ctx.fillText(`æ ¸å¿ƒ: ${state.singularityName}`, canvas.width / 2, 32);
        }
      }
    }

    function drawLayerBackgrounds() {
      const layerHeights = getLayerHeights();
      if (layerHeights.length === 0) return;

      const phaseWidth = (canvas.width - padding.left - padding.right) / state.phases.length;

      layerHeights.forEach(({ layer, y, height }) => {
        state.phases.forEach((phase, phaseIndex) => {
          if (layer.visiblePhases.includes(phase.id)) {
            ctx.fillStyle = hexToRgba(layer.color, 0.12);
            ctx.fillRect(padding.left + phaseIndex * phaseWidth, y, phaseWidth, height);
          }
        });
      });
    }

    // åªç»˜åˆ¶é˜¶æ®µåˆ†éš”çº¿ï¼ˆåœ¨å˜æ¢å†…ç»˜åˆ¶ï¼Œå—ç¼©æ”¾å¹³ç§»å½±å“ï¼‰
    function drawPhaseDividers(isDark) {
      if (state.phases.length === 0) return;
      const phaseWidth = (canvas.width - padding.left - padding.right) / state.phases.length;

      ctx.setLineDash([3, 3]);
      ctx.strokeStyle = isDark ? 'rgba(71, 85, 105, 0.5)' : 'rgba(148, 163, 184, 0.5)';
      ctx.lineWidth = 1;

      state.phases.forEach((phase, index) => {
        if (index > 0) {
          ctx.beginPath();
          ctx.moveTo(padding.left + index * phaseWidth, padding.top);
          ctx.lineTo(padding.left + index * phaseWidth, canvas.height - padding.bottom);
          ctx.stroke();
        }
      });
      ctx.setLineDash([]);
    }

    // ç»˜åˆ¶Xè½´é˜¶æ®µæ ‡ç­¾ï¼ˆå›ºå®šåœ¨åº•éƒ¨ï¼Œä¸å—å˜æ¢å½±å“ï¼‰
    function drawXAxisLabels(isDark) {
      if (state.phases.length === 0) return;
      const phaseWidth = (canvas.width - padding.left - padding.right) / state.phases.length;

      state.phases.forEach((phase, index) => {
        ctx.fillStyle = isDark ? '#9CA3AF' : '#475569';
        ctx.font = '8px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(phase.name, padding.left + index * phaseWidth + phaseWidth / 2, canvas.height - padding.bottom + 14);
        ctx.fillStyle = isDark ? '#64748B' : '#94a3b8';
        ctx.font = '7px monospace';
        ctx.fillText(`${phase.startYear}`, padding.left + index * phaseWidth + phaseWidth / 2, canvas.height - padding.bottom + 24);
      });
    }

    function drawYAxisLabels() {
      const layerHeights = getLayerHeights();
      if (layerHeights.length === 0) return;

      ctx.textAlign = 'right';
      layerHeights.forEach(({ layer, y, height }) => {
        ctx.fillStyle = layer.color;
        ctx.font = '7px -apple-system, sans-serif';
        ctx.fillText(layer.name, padding.left - 4, y + height / 2 + 2);
      });
    }

    // ç»˜åˆ¶åæ ‡è½´åŒºåŸŸèƒŒæ™¯ï¼ˆé®ç›–å¯èƒ½æº¢å‡ºçš„å†…å®¹ï¼‰
    function drawAxesBackground(isDark) {
      const bgColor = isDark ? '#0f172a' : '#ffffff';
      ctx.fillStyle = bgColor;

      // å·¦ä¾§Yè½´åŒºåŸŸèƒŒæ™¯
      ctx.fillRect(0, 0, padding.left, canvas.height);

      // åº•éƒ¨Xè½´åŒºåŸŸèƒŒæ™¯
      ctx.fillRect(0, canvas.height - padding.bottom, canvas.width, padding.bottom);

      // é¡¶éƒ¨æ ‡é¢˜åŒºåŸŸèƒŒæ™¯
      ctx.fillRect(0, 0, canvas.width, padding.top);

      // å³ä¾§è¾¹è·èƒŒæ™¯
      ctx.fillRect(canvas.width - padding.right, 0, padding.right, canvas.height);
    }


    function drawCurve() {
      if (state.curvePoints.length < 2) return;
      const gradient = ctx.createLinearGradient(padding.left, 0, canvas.width - padding.right, 0);
      gradient.addColorStop(0, '#10B981');
      gradient.addColorStop(0.5, '#F59E0B');
      gradient.addColorStop(1, '#EC4899');

      ctx.beginPath();
      ctx.moveTo(state.curvePoints[0].x + padding.left, state.curvePoints[0].y);
      for (let i = 1; i < state.curvePoints.length; i++) {
        const prev = state.curvePoints[i - 1];
        const curr = state.curvePoints[i];
        const cpx = (prev.x + curr.x) / 2 + padding.left;
        const cpy = (prev.y + curr.y) / 2;
        ctx.quadraticCurveTo(prev.x + padding.left, prev.y, cpx, cpy);
      }
      const last = state.curvePoints[state.curvePoints.length - 1];
      ctx.lineTo(last.x + padding.left, last.y);
      ctx.strokeStyle = gradient;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.stroke();
    }

    function drawCurveControlPoints() {
      const isDark = state.darkMode;
      state.curvePoints.forEach((pt) => {
        ctx.beginPath();
        ctx.arc(pt.x + padding.left, pt.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = isDark ? '#1F2937' : '#e2e8f0';
        ctx.fill();
        ctx.strokeStyle = '#60A5FA';
        ctx.lineWidth = 1;
        ctx.stroke();
      });
    }

    function drawConnections() {
      const selectedId = state.selectedItem?.id;
      const selectedType = state.selectedItem?.type;
      const s = state.styles;

      state.connections.forEach(conn => {
        const source = findElementById(conn.sourceType, conn.sourceId);
        const target = findElementById(conn.targetType, conn.targetId);
        if (!source || !target) return;

        const isHighlighted = (selectedType === 'entity' && (conn.sourceId === selectedId || conn.targetId === selectedId)) ||
          (selectedType === 'invariant' && (conn.sourceId === selectedId || conn.targetId === selectedId));

        let lineColor = 'rgba(139, 92, 246, 0.6)';
        if (conn.sourceType === 'invariant') {
          const inv = state.invariants.find(i => i.id === conn.sourceId);
          const invType = state.invariantTypes.find(t => t.id === inv?.typeId);
          if (invType) lineColor = invType.color;
        } else if (conn.targetType === 'invariant') {
          const inv = state.invariants.find(i => i.id === conn.targetId);
          const invType = state.invariantTypes.find(t => t.id === inv?.typeId);
          if (invType) lineColor = invType.color;
        }

        ctx.beginPath();
        ctx.setLineDash(isHighlighted ? [] : [3, 3]);
        ctx.strokeStyle = isHighlighted ? lineColor : hexToRgba(lineColor, 0.5);
        ctx.lineWidth = isHighlighted ? s.highlightWidth : s.connectionWidth;

        if (isHighlighted && s.highlightGlow > 0) {
          ctx.shadowColor = lineColor;
          ctx.shadowBlur = s.highlightGlow;
        }

        ctx.moveTo(source.x, source.y);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.shadowBlur = 0;

        const angle = Math.atan2(target.y - source.y, target.x - source.x);
        const arrowSize = 5;
        const arrowX = target.x - 14 * Math.cos(angle);
        const arrowY = target.y - 14 * Math.sin(angle);
        ctx.beginPath();
        ctx.moveTo(arrowX, arrowY);
        ctx.lineTo(arrowX - arrowSize * Math.cos(angle - Math.PI / 6), arrowY - arrowSize * Math.sin(angle - Math.PI / 6));
        ctx.moveTo(arrowX, arrowY);
        ctx.lineTo(arrowX - arrowSize * Math.cos(angle + Math.PI / 6), arrowY - arrowSize * Math.sin(angle + Math.PI / 6));
        ctx.stroke();
      });
    }

    function findElementById(type, id) {
      if (type === 'entity') return state.entities.find(e => e.id === id);
      if (type === 'invariant') return state.invariants.find(i => i.id === id);
      return null;
    }

    function drawInvariants(isDark) {
      const s = state.styles;
      const size = s.invariantSize;
      const fontSize = s.invariantFontSize;

      state.invariants.forEach(inv => {
        const invType = state.invariantTypes.find(t => t.id === inv.typeId);
        const isSelected = state.selectedItem?.type === 'invariant' && state.selectedItem?.id === inv.id;
        const radius = isSelected ? size + 3 : size;

        if (isSelected) {
          ctx.shadowColor = invType?.color || '#fff';
          ctx.shadowBlur = 10;
        }

        ctx.beginPath();
        ctx.arc(inv.x, inv.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = isDark ? 'rgba(17, 24, 39, 0.9)' : 'rgba(255, 255, 255, 0.9)';
        ctx.fill();
        ctx.strokeStyle = invType?.color || '#fff';
        ctx.lineWidth = isSelected ? 2.5 : 1.5;
        ctx.stroke();
        ctx.shadowBlur = 0;

        ctx.fillStyle = invType?.color || '#fff';
        ctx.font = `bold ${Math.round(size * 0.7)}px -apple-system, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(invType?.symbol || '?', inv.x, inv.y);

        ctx.fillStyle = isDark ? '#E5E7EB' : '#1e293b';
        ctx.font = `${fontSize}px -apple-system, sans-serif`;
        ctx.textBaseline = 'top';
        ctx.fillText(inv.name, inv.x, inv.y + radius + 2);
      });
    }

    function drawEntities(isDark) {
      const s = state.styles;
      const width = s.entityWidth;
      const height = s.entityHeight;
      const fontSize = s.entityFontSize;
      const fontColor = s.entityFontColor;
      const radius = 4;

      state.entities.forEach(ent => {
        const isSelected = state.selectedItem?.type === 'entity' && state.selectedItem?.id === ent.id;
        const attrColors = ent.attributes.map(attrId => state.attributeTypes.find(a => a.id === attrId)?.color).filter(Boolean);

        if (isSelected) {
          ctx.shadowColor = ent.primaryColor;
          ctx.shadowBlur = 10;
        }

        ctx.beginPath();
        ctx.roundRect(ent.x - width / 2, ent.y - height / 2, width, height, radius);

        if (attrColors.length > 1) {
          const gradient = ctx.createLinearGradient(ent.x - width / 2, ent.y, ent.x + width / 2, ent.y);
          attrColors.forEach((color, idx) => {
            gradient.addColorStop(idx / (attrColors.length - 1), color);
          });
          ctx.fillStyle = gradient;
        } else if (attrColors.length === 1) {
          ctx.fillStyle = attrColors[0];
        } else {
          ctx.fillStyle = ent.primaryColor;
        }
        ctx.fill();
        ctx.shadowBlur = 0;

        if (isSelected) {
          ctx.strokeStyle = '#fff';
          ctx.lineWidth = 1.5;
          ctx.stroke();
        }

        ctx.beginPath();
        ctx.roundRect(ent.x - width / 2, ent.y - height / 2, 3, height, [radius, 0, 0, radius]);
        ctx.fillStyle = ent.primaryColor;
        ctx.fill();

        ctx.fillStyle = fontColor;
        ctx.font = `600 ${fontSize}px -apple-system, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const maxChars = Math.floor(width / (fontSize * 0.65));
        const displayName = ent.name.length > maxChars ? ent.name.slice(0, maxChars - 1) + '..' : ent.name;
        ctx.fillText(displayName, ent.x + 1, ent.y);
      });
    }

    function drawAxes(isDark) {
      ctx.setLineDash([]);
      ctx.strokeStyle = isDark ? '#4B5563' : '#94a3b8';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.left, canvas.height - padding.bottom);
      ctx.lineTo(canvas.width - padding.right, canvas.height - padding.bottom);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(padding.left, padding.top);
      ctx.lineTo(padding.left, canvas.height - padding.bottom);
      ctx.stroke();

      ctx.fillStyle = isDark ? '#64748B' : '#94a3b8';
      ctx.font = '7px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('æ—¶é—´ / å‘å±•é˜¶æ®µ â†’', canvas.width / 2, canvas.height - 4);
      ctx.save();
      ctx.translate(9, canvas.height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('ä»·å€¼ â†’', 0, 0);
      ctx.restore();
    }

    // ========== é¢œè‰²é€‰æ‹©å™¨æ¸²æŸ“ ==========
    function renderColorPicker(currentColor, onChangeAttr) {
      return `
        <div class="color-picker-wrapper">
          <input type="color" class="color-picker" value="${currentColor}" ${onChangeAttr}>
          <div class="color-scheme-triggers">
            ${schemeKeys.slice(0, 6).map((name, i) => `
              <div class="color-scheme-trigger" style="background:${colorSchemes[name][0]}" title="${name}">
                <div class="color-scheme-dropdown">
                  <div style="font-size:7px;color:var(--text-dim);margin-bottom:2px;">${name}</div>
                  <div class="color-scheme-dropdown-row">
                    ${colorSchemes[name].map(c => `
                      <div class="color-scheme-color" style="background:${c}" data-color="${c}"></div>
                    `).join('')}
                  </div>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    }

    // ========== UIæ¸²æŸ“ ==========
    function renderAll() {
      renderSymbolButtons();
      renderInvariantsList();
      renderEntitiesList();
      renderAttributesList();
      renderLayersList();
      renderPhasesList();
      renderLegend();
      renderColorSchemePreview();
      updateProjectSelector();
      applyStyles();
      applyDarkMode();
      applyZoom();

      document.getElementById('ecosystemName').value = state.ecosystemName || '';
      document.getElementById('singularityName').value = state.singularityName || '';
      document.getElementById('singularityDesc').value = state.singularityDesc || '';

      render();
    }

    function renderSymbolButtons() {
      document.getElementById('symbolButtons').innerHTML = state.invariantTypes.map(type => `
        <button class="symbol-btn" onclick="addInvariant('${type.id}')" title="æ·»åŠ ${type.name}" style="color: ${type.color}">
          ${type.symbol}
        </button>
      `).join('');
    }

    function renderInvariantsList() {
      const container = document.getElementById('invariantsList');
      if (state.invariants.length === 0) {
        container.innerHTML = '<div class="empty-state">ç‚¹å‡»ä¸Šæ–¹ç¬¦å·æ·»åŠ ä¸åŠ¨ç‚¹</div>';
        return;
      }

      container.innerHTML = state.invariants.map(inv => {
        const invType = state.invariantTypes.find(t => t.id === inv.typeId);
        const isSelected = state.selectedItem?.type === 'invariant' && state.selectedItem?.id === inv.id;

        return `
          <div class="item-card ${isSelected ? 'selected' : ''}" onclick="selectItem('invariant', '${inv.id}')">
            <div class="item-header">
              <div class="item-info">
                <span class="item-symbol" style="color: ${invType?.color}">${invType?.symbol}</span>
                <input type="text" class="item-input" value="${inv.name}" 
                  onchange="updateInvariant('${inv.id}', 'name', this.value)" onclick="event.stopPropagation()">
              </div>
              <button class="delete-btn" onclick="event.stopPropagation(); deleteInvariant('${inv.id}')">Ã—</button>
            </div>
            <div class="item-row">
              <span class="item-label">é¢œè‰²</span>
              ${renderColorPicker(invType?.color || '#8B5CF6', `onchange="updateInvariantTypeColor('${inv.typeId}', this.value)" onclick="event.stopPropagation()"`)}
            </div>
            <select class="item-select" onchange="updateInvariant('${inv.id}', 'layerId', parseInt(this.value))" onclick="event.stopPropagation()">
              ${state.valueLayers.map(layer => `<option value="${layer.id}" ${inv.layerId === layer.id ? 'selected' : ''}>${layer.name}</option>`).join('')}
            </select>
          </div>
        `;
      }).join('');

      bindColorSchemeClicks();
    }

    function renderEntitiesList() {
      const container = document.getElementById('entitiesList');
      if (state.entities.length === 0) {
        container.innerHTML = '<div class="empty-state">ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®æ·»åŠ å…¬å¸</div>';
        return;
      }

      container.innerHTML = state.entities.map(ent => {
        const isSelected = state.selectedItem?.type === 'entity' && state.selectedItem?.id === ent.id;

        return `
          <div class="item-card ${isSelected ? 'selected' : ''}" onclick="selectItem('entity', '${ent.id}')">
            <div class="item-header">
              <div class="item-info">
                <div class="color-preview" style="background-color: ${ent.primaryColor}"></div>
                <input type="text" class="item-input" value="${ent.name}" 
                  onchange="updateEntity('${ent.id}', 'name', this.value)" onclick="event.stopPropagation()">
              </div>
              <button class="delete-btn" onclick="event.stopPropagation(); deleteEntity('${ent.id}')">Ã—</button>
            </div>
            <div class="item-row">
              <span class="item-label">ä¸»è‰²</span>
              ${renderColorPicker(ent.primaryColor, `onchange="updateEntity('${ent.id}', 'primaryColor', this.value)" onclick="event.stopPropagation()"`)}
            </div>
            <div class="item-row">
              <span class="item-label">å±‚çº§</span>
              <select class="item-select" style="flex:1" onchange="updateEntity('${ent.id}', 'layerId', parseInt(this.value))" onclick="event.stopPropagation()">
                ${state.valueLayers.map(layer => `<option value="${layer.id}" ${ent.layerId === layer.id ? 'selected' : ''}>${layer.name}</option>`).join('')}
              </select>
            </div>
            <div class="attr-tags">
              ${state.attributeTypes.map(attr => {
          const isActive = ent.attributes.includes(attr.id);
          return `<button class="attr-tag ${isActive ? 'active' : ''}" 
                  style="${isActive ? `background-color: ${attr.color}` : ''}"
                  onclick="event.stopPropagation(); toggleEntityAttribute('${ent.id}', '${attr.id}')">${attr.name}</button>`;
        }).join('')}
            </div>
          </div>
        `;
      }).join('');

      bindColorSchemeClicks();
    }

    function renderAttributesList() {
      document.getElementById('attributesList').innerHTML = state.attributeTypes.map(attr => `
        <div class="item-card">
          <div class="item-header">
            <div class="item-info">
              ${renderColorPicker(attr.color, `onchange="updateAttributeType('${attr.id}', 'color', this.value)"`)}
              <input type="text" class="item-input" value="${attr.name}" style="width: 80px" onchange="updateAttributeType('${attr.id}', 'name', this.value)">
            </div>
            <button class="delete-btn" onclick="deleteAttributeType('${attr.id}')">Ã—</button>
          </div>
        </div>
      `).join('');

      bindColorSchemeClicks();
    }

    function renderLayersList() {
      document.getElementById('layersList').innerHTML = state.valueLayers.map((layer, index) => `
        <div class="item-card">
          <div class="item-header">
            <div class="item-info">
              ${renderColorPicker(layer.color, `onchange="updateLayer(${index}, 'color', this.value)"`)}
              <input type="text" class="item-input" value="${layer.name}" style="width: 70px" onchange="updateLayer(${index}, 'name', this.value)">
            </div>
            <button class="delete-btn" onclick="deleteLayer(${index})">Ã—</button>
          </div>
          <div class="item-row">
            <span class="item-label">é«˜åº¦æƒé‡</span>
            <input type="range" min="0.5" max="3" step="0.1" value="${layer.heightWeight || 1}" 
              style="width:60px" onchange="updateLayer(${index}, 'heightWeight', parseFloat(this.value))">
            <span style="font-size:7px;color:var(--text-dim)">${(layer.heightWeight || 1).toFixed(1)}</span>
          </div>
          <div class="section-title" style="margin-top: 4px;">æ˜¾ç¤ºé˜¶æ®µï¼š</div>
          <div class="phase-visibility">
            ${state.phases.map(phase => `
              <label class="phase-check">
                <input type="checkbox" ${layer.visiblePhases?.includes(phase.id) ? 'checked' : ''}
                  onchange="toggleLayerPhase(${index}, ${phase.id}, this.checked)">
                ${phase.name}
              </label>
            `).join('')}
          </div>
        </div>
      `).join('');

      bindColorSchemeClicks();
    }

    function renderPhasesList() {
      document.getElementById('phasesList').innerHTML = state.phases.map((phase, index) => `
        <div class="item-card">
          <div class="item-header">
            <input type="text" class="item-input" value="${phase.name}" style="width: 55px; font-weight: 500; color: var(--accent-primary);"
              onchange="updatePhase(${index}, 'name', this.value)">
            <button class="delete-btn" onclick="deletePhase(${index})">Ã—</button>
          </div>
          <div class="item-row">
            <span class="item-label">å¹´ä»½</span>
            <input type="number" class="config-input small" value="${phase.startYear}" 
              onchange="updatePhase(${index}, 'startYear', parseInt(this.value))">
            <span class="item-label">~</span>
            <input type="number" class="config-input small" value="${phase.endYear || ''}" 
              onchange="updatePhase(${index}, 'endYear', parseInt(this.value))">
          </div>
        </div>
      `).join('');
    }

    function renderColorSchemePreview() {
      document.getElementById('colorSchemePreview').innerHTML = Object.entries(colorSchemes).map(([name, colors]) => `
        <div style="margin-bottom: 6px;">
          <div style="font-size: 8px; color: var(--text-muted); margin-bottom: 2px;">${name}</div>
          <div style="display: flex; gap: 2px; flex-wrap: wrap;">
            ${colors.map(color => `
              <div style="width:12px;height:12px;border-radius:2px;background:${color};cursor:pointer" 
                onclick="navigator.clipboard.writeText('${color}')" title="ç‚¹å‡»å¤åˆ¶: ${color}"></div>
            `).join('')}
          </div>
        </div>
      `).join('');
    }

    function bindColorSchemeClicks() {
      document.querySelectorAll('.color-scheme-color').forEach(el => {
        el.onclick = (e) => {
          e.stopPropagation();
          const color = el.dataset.color;
          const picker = el.closest('.color-picker-wrapper').querySelector('.color-picker');
          if (picker) {
            picker.value = color;
            picker.dispatchEvent(new Event('change'));
          }
        };
      });
    }

    function renderLegend() {
      const layerLegend = state.valueLayers.slice().reverse().map(layer => `
        <div class="legend-item">
          <div class="legend-color" style="background-color: ${layer.color}; opacity: 0.6"></div>
          <span>${layer.name}</span>
        </div>
      `).join('');

      const invariantLegend = state.invariantTypes.map(type => `
        <div class="legend-item">
          <span style="color: ${type.color}">${type.symbol}</span>
        </div>
      `).join('');

      document.getElementById('legendContent').innerHTML = `
        <span class="legend-label">å±‚çº§:</span>${layerLegend}
        <div class="legend-divider"></div>
        <span class="legend-label">ç¬¦å·:</span>${invariantLegend}
      `;
    }

    // ========== æ“ä½œå‡½æ•° ==========
    function updateSingularity() {
      state.ecosystemName = document.getElementById('ecosystemName').value;
      state.singularityName = document.getElementById('singularityName').value;
      state.singularityDesc = document.getElementById('singularityDesc').value;
      render();
    }

    function addInvariant(typeId) {
      saveStateForUndo();
      const invType = state.invariantTypes.find(t => t.id === typeId);
      state.invariants.push({
        id: generateId(),
        typeId: typeId,
        name: `${invType?.name || 'æ–°'}ä¸åŠ¨ç‚¹`,
        x: 120 + Math.random() * (canvas.width - 200),
        y: padding.top + 40 + Math.random() * (canvas.height - padding.top - padding.bottom - 80),
        layerId: 1,
        note: ''
      });
      renderInvariantsList();
      renderEntitiesList();
      render();
    }

    function addEntity() {
      saveStateForUndo();
      state.entities.push({
        id: generateId(),
        name: 'æ–°å…¬å¸',
        x: 120 + Math.random() * (canvas.width - 200),
        y: padding.top + 40 + Math.random() * (canvas.height - padding.top - padding.bottom - 80),
        layerId: 1,
        invariantId: null,
        primaryColor: '#6B7280',
        attributes: [],
        note: ''
      });
      renderEntitiesList();
      render();
    }

    function addAttributeType() {
      saveStateForUndo();
      state.attributeTypes.push({ id: generateId(), name: 'æ–°å±æ€§', color: '#9CA3AF' });
      renderAttributesList();
      renderEntitiesList();
    }

    function addLayer() {
      saveStateForUndo();
      const newId = Math.max(0, ...state.valueLayers.map(l => l.id)) + 1;
      state.valueLayers.push({
        id: newId,
        name: 'æ–°å±‚çº§',
        color: '#9CA3AF',
        description: '',
        visiblePhases: state.phases.map(p => p.id),
        heightWeight: 1
      });
      renderLayersList();
      renderLegend();
      render();
    }

    function addPhase() {
      saveStateForUndo();
      const lastPhase = state.phases[state.phases.length - 1];
      const newId = Math.max(0, ...state.phases.map(p => p.id)) + 1;
      state.phases.push({
        id: newId,
        name: 'æ–°é˜¶æ®µ',
        startYear: lastPhase ? lastPhase.endYear || lastPhase.startYear + 4 : 2024,
        endYear: lastPhase ? (lastPhase.endYear || lastPhase.startYear + 4) + 4 : 2028,
        proximity: '',
        task: ''
      });
      extendCurveForNewPhase();
      renderPhasesList();
      renderLayersList();
      render();
    }

    function updateInvariant(id, field, value) {
      const inv = state.invariants.find(i => i.id === id);
      if (inv) { inv[field] = value; renderInvariantsList(); renderEntitiesList(); render(); }
    }

    function updateInvariantTypeColor(typeId, color) {
      const invType = state.invariantTypes.find(t => t.id === typeId);
      if (invType) {
        invType.color = color;
        renderInvariantsList();
        renderSymbolButtons();
        renderLegend();
        render();
      }
    }

    function updateEntity(id, field, value) {
      const ent = state.entities.find(e => e.id === id);
      if (ent) { ent[field] = value; renderEntitiesList(); render(); }
    }

    function updateAttributeType(id, field, value) {
      const attr = state.attributeTypes.find(a => a.id === id);
      if (attr) { attr[field] = value; renderAttributesList(); renderEntitiesList(); renderLegend(); render(); }
    }

    function updateLayer(index, field, value) {
      state.valueLayers[index][field] = value;
      renderLayersList();
      renderLegend();
      render();
    }

    function updatePhase(index, field, value) {
      state.phases[index][field] = value;
      renderPhasesList();
      renderLayersList();
      render();
    }

    function toggleLayerPhase(layerIndex, phaseId, checked) {
      const layer = state.valueLayers[layerIndex];
      if (!layer.visiblePhases) layer.visiblePhases = [];
      if (checked && !layer.visiblePhases.includes(phaseId)) {
        layer.visiblePhases.push(phaseId);
      } else if (!checked) {
        layer.visiblePhases = layer.visiblePhases.filter(id => id !== phaseId);
      }
      render();
    }

    function toggleEntityAttribute(entityId, attrId) {
      const ent = state.entities.find(e => e.id === entityId);
      if (ent) {
        const idx = ent.attributes.indexOf(attrId);
        if (idx >= 0) ent.attributes.splice(idx, 1);
        else ent.attributes.push(attrId);
        renderEntitiesList();
        render();
      }
    }

    function deleteInvariant(id) {
      saveStateForUndo();
      state.invariants = state.invariants.filter(i => i.id !== id);
      state.entities.forEach(e => { if (e.invariantId === id) e.invariantId = null; });
      state.connections = state.connections.filter(c => !(c.sourceType === 'invariant' && c.sourceId === id) && !(c.targetType === 'invariant' && c.targetId === id));
      renderInvariantsList();
      renderEntitiesList();
      render();
    }

    function deleteEntity(id) {
      saveStateForUndo();
      state.entities = state.entities.filter(e => e.id !== id);
      state.connections = state.connections.filter(c => !(c.sourceType === 'entity' && c.sourceId === id) && !(c.targetType === 'entity' && c.targetId === id));
      renderEntitiesList();
      render();
    }

    function deleteAttributeType(id) {
      saveStateForUndo();
      state.attributeTypes = state.attributeTypes.filter(a => a.id !== id);
      state.entities.forEach(e => { e.attributes = e.attributes.filter(a => a !== id); });
      renderAttributesList();
      renderEntitiesList();
      render();
    }

    function deleteLayer(index) {
      saveStateForUndo();
      state.valueLayers.splice(index, 1);
      renderLayersList();
      renderLegend();
      render();
    }

    function deletePhase(index) {
      saveStateForUndo();
      const phaseId = state.phases[index].id;
      state.phases.splice(index, 1);
      state.valueLayers.forEach(l => {
        if (l.visiblePhases) l.visiblePhases = l.visiblePhases.filter(id => id !== phaseId);
      });
      renderPhasesList();
      renderLayersList();
      render();
    }

    function selectItem(type, id) {
      state.selectedItem = { type, id };
      renderInvariantsList();
      renderEntitiesList();
      render();
    }

    // ========== ä¾§è¾¹æ  ==========
    function toggleSidebar() {
      const sidebar = document.getElementById('sidebar');
      sidebar.classList.toggle('collapsed');
      updateTogglePosition();
      setTimeout(resizeCanvas, 100);
    }

    function updateTogglePosition() {
      const sidebar = document.getElementById('sidebar');
      const toggle = document.getElementById('sidebarToggle');
      if (!sidebar.classList.contains('collapsed')) {
        toggle.style.left = sidebar.offsetWidth + 'px';
      }
    }

    const resizer = document.getElementById('sidebarResizer');
    let isResizing = false;

    resizer.addEventListener('mousedown', () => {
      isResizing = true;
      resizer.classList.add('dragging');
      document.body.style.cursor = 'ew-resize';
      document.body.style.userSelect = 'none';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isResizing) return;
      const sidebar = document.getElementById('sidebar');
      const newWidth = Math.max(160, Math.min(360, e.clientX));
      sidebar.style.width = newWidth + 'px';
      sidebarWidth = newWidth;
      updateTogglePosition();
    });

    document.addEventListener('mouseup', () => {
      if (isResizing) {
        isResizing = false;
        resizer.classList.remove('dragging');
        document.body.style.cursor = '';
        document.body.style.userSelect = '';
        resizeCanvas();
      }
    });

    // ========== Tabåˆ‡æ¢ ==========
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(`${btn.dataset.tab}-panel`).classList.add('active');
      });
    });

    // ========== ç”»å¸ƒäº¤äº’ ==========
    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      // è®¡ç®—ç”»å¸ƒä¸­å¿ƒï¼ˆç”¨äºç¼©æ”¾å˜æ¢ï¼‰
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      // è·å–ç›¸å¯¹äºç”»å¸ƒçš„åŸå§‹åæ ‡
      const rawX = e.clientX - rect.left;
      const rawY = e.clientY - rect.top;
      // é€†å‘åº”ç”¨å˜æ¢ï¼šå…ˆé€†å‘å¹³ç§»ï¼Œå†é€†å‘ç¼©æ”¾ï¼ˆä»¥ä¸­å¿ƒä¸ºåŸç‚¹ï¼‰
      const scaledX = (rawX - centerX) / state.zoom + centerX;
      const scaledY = (rawY - centerY) / state.zoom + centerY;
      // æœ€åé€†å‘åº”ç”¨å¹³ç§»
      return {
        x: scaledX - panState.panX,
        y: scaledY - panState.panY
      };
    }

    function findItemAtPos(pos) {
      const s = state.styles;
      const entW = s.entityWidth / 2;
      const entH = s.entityHeight / 2;

      for (let i = state.entities.length - 1; i >= 0; i--) {
        const ent = state.entities[i];
        if (pos.x >= ent.x - entW && pos.x <= ent.x + entW && pos.y >= ent.y - entH && pos.y <= ent.y + entH) {
          return { type: 'entity', item: ent, index: i };
        }
      }

      const invSize = s.invariantSize + 2;
      for (let i = state.invariants.length - 1; i >= 0; i--) {
        const inv = state.invariants[i];
        const dist = Math.sqrt((pos.x - inv.x) ** 2 + (pos.y - inv.y) ** 2);
        if (dist <= invSize) return { type: 'invariant', item: inv, index: i };
      }

      if (state.showCurvePoints) {
        for (let i = 0; i < state.curvePoints.length; i++) {
          const pt = state.curvePoints[i];
          const dist = Math.sqrt((pos.x - (pt.x + padding.left)) ** 2 + (pos.y - pt.y) ** 2);
          if (dist <= 6) return { type: 'curvePoint', item: pt, index: i };
        }
      }

      // æ£€æµ‹è¿çº¿
      for (let i = state.connections.length - 1; i >= 0; i--) {
        const conn = state.connections[i];
        const source = conn.sourceType === 'entity'
          ? state.entities.find(e => e.id === conn.sourceId)
          : state.invariants.find(inv => inv.id === conn.sourceId);
        const target = conn.targetType === 'entity'
          ? state.entities.find(e => e.id === conn.targetId)
          : state.invariants.find(inv => inv.id === conn.targetId);

        if (source && target) {
          // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
          const distToLine = pointToLineDistance(pos.x, pos.y, source.x, source.y, target.x, target.y);
          if (distToLine <= 6) {
            return { type: 'connection', item: conn, index: i };
          }
        }
      }

      return null;
    }

    // è®¡ç®—ç‚¹åˆ°çº¿æ®µçš„è·ç¦»
    function pointToLineDistance(px, py, x1, y1, x2, y2) {
      const A = px - x1;
      const B = py - y1;
      const C = x2 - x1;
      const D = y2 - y1;

      const dot = A * C + B * D;
      const lenSq = C * C + D * D;
      let param = -1;

      if (lenSq !== 0) param = dot / lenSq;

      let xx, yy;
      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }

      const dx = px - xx;
      const dy = py - yy;
      return Math.sqrt(dx * dx + dy * dy);
    }

    canvas.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;

      // ç©ºæ ¼é”®æŒ‰ä¸‹æ—¶è¿›å…¥å¹³ç§»æ¨¡å¼
      if (panState.spacePressed) {
        panState.isPanning = true;
        panState.startX = e.clientX - panState.panX;
        panState.startY = e.clientY - panState.panY;
        canvas.style.cursor = 'grabbing';
        return;
      }

      const pos = getMousePos(e);
      const found = findItemAtPos(pos);

      if (connectionMode.active && found && found.type !== 'curvePoint') {
        if (connectionMode.source.type !== found.type || connectionMode.source.item.id !== found.item.id) {
          saveStateForUndo();
          state.connections.push({
            id: generateId(),
            sourceType: connectionMode.source.type,
            sourceId: connectionMode.source.item.id,
            targetType: found.type,
            targetId: found.item.id
          });
        }
        connectionMode = { active: false, source: null };
        document.getElementById('connectionModeIndicator').classList.remove('show');
        render();
        return;
      }

      if (found) {
        state.draggedItem = found;
        if (found.type !== 'curvePoint') {
          state.selectedItem = { type: found.type, id: found.item.id };
          renderInvariantsList();
          renderEntitiesList();
        }
        canvas.style.cursor = 'grabbing';
      } else {
        state.selectedItem = null;
        renderInvariantsList();
        renderEntitiesList();
      }
      render();
    });

    canvas.addEventListener('mousemove', (e) => {
      // å¹³ç§»æ¨¡å¼
      if (panState.isPanning) {
        panState.panX = e.clientX - panState.startX;
        panState.panY = e.clientY - panState.startY;
        render();
        return;
      }

      const pos = getMousePos(e);

      if (state.draggedItem) {
        const newX = Math.max(padding.left, Math.min(canvas.width - padding.right, pos.x));
        const newY = Math.max(padding.top, Math.min(canvas.height - padding.bottom, pos.y));

        if (state.draggedItem.type === 'invariant' || state.draggedItem.type === 'entity') {
          state.draggedItem.item.x = newX;
          state.draggedItem.item.y = newY;
        } else if (state.draggedItem.type === 'curvePoint') {
          const idx = state.draggedItem.index;
          const minX = idx > 0 ? state.curvePoints[idx - 1].x + 8 : 0;
          const maxX = idx < state.curvePoints.length - 1 ? state.curvePoints[idx + 1].x - 8 : canvas.width - padding.left - padding.right;
          state.curvePoints[idx].x = Math.max(minX, Math.min(maxX, pos.x - padding.left));
          state.curvePoints[idx].y = Math.max(padding.top + 8, Math.min(canvas.height - padding.bottom - 8, newY));
        }
        render();
      } else {
        const found = findItemAtPos(pos);
        canvas.style.cursor = found ? 'grab' : 'default';

        const tooltip = document.getElementById('tooltip');
        // å¦‚æœ tooltip å·²ç»è¢«é”å®šï¼Œä¸è¦æ›´æ–°
        if (tooltip.classList.contains('pinned')) {
          return;
        }
        if (found && state.styles.showTooltips !== false) {
          let tooltipHTML = '';

          if (found.type === 'entity') {
            const ent = found.item;
            const attrs = ent.attributes.map(attrId => state.attributeTypes.find(a => a.id === attrId)).filter(Boolean);
            tooltipHTML += `<div class="tooltip-title">${ent.name}</div>`;
            if (attrs.length > 0) {
              tooltipHTML += `<div class="tooltip-attrs">`;
              attrs.forEach(attr => {
                tooltipHTML += `<span class="tooltip-attr" style="background-color: ${attr.color}">${attr.name}</span>`;
              });
              tooltipHTML += `</div>`;
            }
            if (ent.note || ent.noteImages?.length || ent.noteImage) tooltipHTML += `<div class="tooltip-note">${renderNoteContent(ent.note, ent.noteImages || ent.noteImage)}</div>`;
          } else if (found.type === 'invariant') {
            const inv = found.item;
            const invType = state.invariantTypes.find(t => t.id === inv.typeId);
            tooltipHTML += `<div class="tooltip-title">${invType?.symbol || ''} ${inv.name}</div>`;
            if (inv.note || inv.noteImages?.length || inv.noteImage) tooltipHTML += `<div class="tooltip-note">${renderNoteContent(inv.note, inv.noteImages || inv.noteImage)}</div>`;
          } else if (found.type === 'curvePoint') {
            const pt = found.item;
            if (pt.note || pt.noteImages?.length || pt.noteImage) {
              tooltipHTML += `<div class="tooltip-title">ğŸ“Œ äº‹ä»¶</div>`;
              tooltipHTML += `<div class="tooltip-note">${renderNoteContent(pt.note, pt.noteImages || pt.noteImage)}</div>`;
            }
          }

          if (tooltipHTML) {
            tooltip.innerHTML = tooltipHTML;
            // æ™ºèƒ½å®šä½
            positionTooltip(tooltip, e.clientX + 8, e.clientY + 8);
            tooltip.classList.add('show');
          } else {
            tooltip.classList.remove('show');
          }
        } else {
          tooltip.classList.remove('show');
        }
      }
    });

    canvas.addEventListener('mouseup', () => {
      panState.isPanning = false;
      state.draggedItem = null;
      canvas.style.cursor = panState.spacePressed ? 'grab' : 'default';
    });

    canvas.addEventListener('mouseleave', () => {
      panState.isPanning = false;
      state.draggedItem = null;
      canvas.style.cursor = 'default';
      // å¦‚æœ tooltip æ²¡æœ‰è¢«é”å®šï¼Œåˆ™ç«‹å³éšè—
      const tooltip = document.getElementById('tooltip');
      if (!tooltip.classList.contains('pinned')) {
        tooltip.classList.remove('show');
      }
    });

    // ========== å³é”®èœå• ==========
    canvas.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      const pos = getMousePos(e);
      const found = findItemAtPos(pos);

      if (found) {
        contextTarget = found;
        const menu = document.getElementById('contextMenu');
        const copyItem = document.getElementById('copyMenuItem');
        const connectItem = document.getElementById('connectMenuItem');
        // è¿çº¿ç±»å‹ï¼šåªæ˜¾ç¤ºç¼–è¾‘æ³¨é‡Šå’Œåˆ é™¤
        const isConnection = found.type === 'connection';
        const isCurvePoint = found.type === 'curvePoint';
        copyItem.style.display = isConnection ? 'none' : 'flex';
        connectItem.style.display = (isCurvePoint || isConnection) ? 'none' : 'flex';
        menu.style.left = e.clientX + 'px';
        menu.style.top = e.clientY + 'px';
        menu.classList.add('show');
      }
    });

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.context-menu')) {
        document.getElementById('contextMenu').classList.remove('show');
      }
    });

    function contextMenuAction(action) {
      document.getElementById('contextMenu').classList.remove('show');
      if (!contextTarget) return;

      if (action === 'copy') {
        saveStateForUndo();
        if (contextTarget.type === 'entity') {
          const src = contextTarget.item;
          state.entities.push({
            ...JSON.parse(JSON.stringify(src)),
            id: generateId(),
            name: src.name + ' (å¤åˆ¶)',
            x: src.x + 15,
            y: src.y + 15
          });
          renderEntitiesList();
        } else if (contextTarget.type === 'invariant') {
          const src = contextTarget.item;
          state.invariants.push({
            ...JSON.parse(JSON.stringify(src)),
            id: generateId(),
            name: src.name + ' (å¤åˆ¶)',
            x: src.x + 15,
            y: src.y + 15
          });
          renderInvariantsList();
        } else if (contextTarget.type === 'curvePoint') {
          const idx = contextTarget.index;
          const pt = state.curvePoints[idx];
          state.curvePoints.splice(idx + 1, 0, { x: pt.x + 30, y: Math.max(padding.top + 10, pt.y - 10), note: '' });
        }
        render();
      } else if (action === 'addNote') {
        // åˆå§‹åŒ–æ³¨é‡Šå†…å®¹
        const noteText = contextTarget.item.note || '';
        document.getElementById('noteContent').value = noteText;

        // åˆå§‹åŒ–å›¾ç‰‡åˆ—è¡¨ï¼ˆå…¼å®¹æ—§çš„å•å›¾ç‰‡æ ¼å¼ï¼‰
        let images = contextTarget.item.noteImages || [];
        if (contextTarget.item.noteImage && !images.length) {
          images = [contextTarget.item.noteImage];
        }
        window.pendingNoteImages = [...images];
        renderNoteImagesPreview();

        document.getElementById('noteModal').classList.add('show');
      } else if (action === 'startConnect') {
        if (contextTarget.type !== 'curvePoint') {
          connectionMode = { active: true, source: contextTarget };
          document.getElementById('connectionModeIndicator').classList.add('show');
        }
      } else if (action === 'delete') {
        saveStateForUndo();
        if (contextTarget.type === 'entity') deleteEntity(contextTarget.item.id);
        else if (contextTarget.type === 'invariant') deleteInvariant(contextTarget.item.id);
        else if (contextTarget.type === 'curvePoint' && state.curvePoints.length > 2) {
          state.curvePoints.splice(contextTarget.index, 1);
          render();
        } else if (contextTarget.type === 'connection') {
          state.connections.splice(contextTarget.index, 1);
          render();
        }
      }
    }

    function saveNote() {
      if (contextTarget) {
        contextTarget.item.note = document.getElementById('noteContent').value;
        contextTarget.item.noteImages = window.pendingNoteImages || [];
        // æ¸…é™¤æ—§çš„å•å›¾ç‰‡å­—æ®µ
        delete contextTarget.item.noteImage;
        render();
      }
      window.pendingNoteImages = [];
      closeModal('noteModal');
    }

    // ========== å›¾ç‰‡æ³¨é‡ŠåŠŸèƒ½ï¼ˆå¤šå›¾ç‰‡æ”¯æŒï¼‰==========
    window.pendingNoteImages = [];

    // æ¸²æŸ“å›¾ç‰‡é¢„è§ˆåˆ—è¡¨
    function renderNoteImagesPreview() {
      const container = document.getElementById('noteImagesContainer');
      container.innerHTML = '';

      window.pendingNoteImages.forEach((imgSrc, index) => {
        const wrapper = document.createElement('div');
        wrapper.style.cssText = 'position: relative; display: inline-block;';
        wrapper.innerHTML = `
          <img src="${imgSrc}" style="max-width: 80px; max-height: 60px; border-radius: 4px; border: 1px solid var(--border-color);">
          <button onclick="removeNoteImageAt(${index})" style="position: absolute; top: -6px; right: -6px; width: 16px; height: 16px; border-radius: 50%; border: none; background: #ef4444; color: white; font-size: 10px; cursor: pointer; display: flex; align-items: center; justify-content: center;">Ã—</button>
        `;
        container.appendChild(wrapper);
      });
    }

    // å¤„ç†å›¾ç‰‡é€‰æ‹©ï¼ˆæ”¯æŒå¤šå¼ ï¼‰
    function handleNoteImageSelect(event) {
      const files = event.target.files;
      for (let file of files) {
        if (file.type.startsWith('image/')) {
          const reader = new FileReader();
          reader.onload = function (e) {
            window.pendingNoteImages.push(e.target.result);
            renderNoteImagesPreview();
          };
          reader.readAsDataURL(file);
        }
      }
      event.target.value = ''; // æ¸…ç©ºinputä»¥ä¾¿å†æ¬¡é€‰æ‹©ç›¸åŒæ–‡ä»¶
    }

    // ç§»é™¤æŒ‡å®šç´¢å¼•çš„å›¾ç‰‡
    function removeNoteImageAt(index) {
      window.pendingNoteImages.splice(index, 1);
      renderNoteImagesPreview();
    }

    // ç²˜è´´å›¾ç‰‡æ”¯æŒ
    document.addEventListener('paste', function (e) {
      const noteModal = document.getElementById('noteModal');
      if (!noteModal.classList.contains('show')) return;

      const items = e.clipboardData?.items;
      if (!items) return;

      for (let item of items) {
        if (item.type.startsWith('image/')) {
          e.preventDefault();
          const file = item.getAsFile();
          const reader = new FileReader();
          reader.onload = function (evt) {
            window.pendingNoteImages.push(evt.target.result);
            renderNoteImagesPreview();
          };
          reader.readAsDataURL(file);
        }
      }
    });

    // æ¸²æŸ“æ³¨é‡Šå†…å®¹ï¼ˆæ”¯æŒå¤šå›¾ç‰‡ï¼‰
    function renderNoteContent(note, noteImages) {
      let html = '';
      if (note) {
        // ä½¿ç”¨ marked æ¸²æŸ“ Markdown
        try {
          // é…ç½® marked é€‰é¡¹ï¼šgfm (GitHubé£æ ¼) ä¸º trueï¼Œbreaks (å›è½¦æ¢è¡Œ) ä¸º true
          marked.setOptions({
            gfm: true,
            breaks: true
          });
          html += marked.parse(note);
        } catch (e) {
          console.error('Markdown rendering error:', e);
          html += escapeHtml(note);
        }
      }
      // å…¼å®¹æ—§æ ¼å¼ï¼ˆå•å›¾ç‰‡å­—æ®µï¼‰
      if (typeof noteImages === 'string' && noteImages) {
        noteImages = [noteImages];
      }
      if (noteImages && noteImages.length > 0) {
        noteImages.forEach(imgSrc => {
          html += `<img src="${imgSrc}" alt="æ³¨é‡Šå›¾ç‰‡" title="åŒå‡»æ”¾å¤§æŸ¥çœ‹">`;
        });
      }
      return html;
    }

    // è½¬ä¹‰ HTML
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }


    // ========== Tooltip \u53cc\u51fb\u9501\u5b9a\u903b\u8f91 ==========
    // \u53cc\u51fb\u5143\u7d20\u9501\u5b9a tooltip
    // å…¨å±€æ‹–æ‹½çŠ¶æ€
    let isDraggingTooltip = false;
    let dragTooltipOffset = { x: 0, y: 0 };

    // æ™ºèƒ½å®šä½å‡½æ•°
    function positionTooltip(tooltip, x, y) {
      tooltip.style.left = x + 'px';
      tooltip.style.top = y + 'px';
      tooltip.style.fontSize = (state.styles.tooltipFontSize || 8) + 'px';

      // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿åœ¨æ¸²æŸ“åè·å–å°ºå¯¸
      requestAnimationFrame(() => {
        const rect = tooltip.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        let newLeft = x;
        let newTop = y;

        // å¦‚æœåº•éƒ¨è¶…å‡ºå±å¹•ï¼Œåˆ™å¾€ä¸Šç¿»
        if (newTop + rect.height > viewportHeight) {
          newTop = y - rect.height - 16; // 16px offset to clear cursor
          // å¦‚æœç¿»ä¸Šå»åé¡¶éƒ¨è¶…å‡ºå±å¹•ï¼ˆå¤ªé«˜äº†ï¼‰ï¼Œåˆ™é¡¶æ ¼æ˜¾ç¤º
          if (newTop < 0) newTop = 10;
        }

        // å¦‚æœå³ä¾§è¶…å‡ºå±å¹•ï¼Œåˆ™å¾€å·¦ç¿»
        if (newLeft + rect.width > viewportWidth) {
          newLeft = x - rect.width - 16; // 16px offset
          // å¦‚æœå·¦ä¾§è¶…å‡ºå±å¹•ï¼Œåˆ™å·¦é¡¶æ ¼
          if (newLeft < 0) newLeft = 10;
        }

        tooltip.style.left = newLeft + 'px';
        tooltip.style.top = newTop + 'px';
      });
    }

    canvas.addEventListener('dblclick', function (e) {
      if (panState.isPanning || state.draggedItem) return;
      const pos = getMousePos(e);
      const found = findItemAtPos(pos);
      const tooltip = document.getElementById('tooltip');

      if (found && state.styles.showTooltips !== false) {
        const hasNote = (found.type === 'entity' && (found.item.note || found.item.noteImages?.length || found.item.noteImage)) ||
          (found.type === 'invariant' && (found.item.note || found.item.noteImages?.length || found.item.noteImage)) ||
          (found.type === 'curvePoint' && (found.item.note || found.item.noteImages?.length || found.item.noteImage));
        if (hasNote) {
          // ç”Ÿæˆå¸¦å…³é—­æŒ‰é’®çš„ tooltip å†…å®¹
          let tooltipHTML = '<div class="tooltip-header-row"><span class="tooltip-close" onclick="closeTooltip()">Ã—</span></div>';

          if (found.type === 'entity') {
            const ent = found.item;
            const attrs = ent.attributes.map(attrId => state.attributeTypes.find(a => a.id === attrId)).filter(Boolean);
            // ä¿®æ”¹ï¼šå°†æ ‡é¢˜ï¼ˆnameï¼‰ä½œä¸ºæ‹–æ‹½æ‰‹æŸ„
            tooltipHTML = `<div class="tooltip-title" id="tooltip-drag-handle">
                <span>${ent.name}</span>
                <span class="tooltip-close" onclick="closeTooltip()">Ã—</span>
              </div>`;
            if (attrs.length > 0) {
              tooltipHTML += `<div class="tooltip-attrs">`;
              attrs.forEach(attr => {
                tooltipHTML += `<span class="tooltip-attr" style="background-color: ${attr.color}">${attr.name}</span>`;
              });
              tooltipHTML += `</div>`;
            }
            if (ent.note || ent.noteImages?.length || ent.noteImage) tooltipHTML += `<div class="tooltip-note">${renderNoteContent(ent.note, ent.noteImages || ent.noteImage)}</div>`;
          } else if (found.type === 'invariant') {
            const inv = found.item;
            const invType = state.invariantTypes.find(t => t.id === inv.typeId);
            tooltipHTML = `<div class="tooltip-title" id="tooltip-drag-handle">
                <span>${invType?.symbol || ''} ${inv.name}</span>
                <span class="tooltip-close" onclick="closeTooltip()">Ã—</span>
              </div>`;
            if (inv.note || inv.noteImages?.length || inv.noteImage) tooltipHTML += `<div class="tooltip-note">${renderNoteContent(inv.note, inv.noteImages || inv.noteImage)}</div>`;
          } else if (found.type === 'curvePoint') {
            const pt = found.item;
            if (pt.note || pt.noteImages?.length || pt.noteImage) {
              tooltipHTML = `<div class="tooltip-title" id="tooltip-drag-handle">
                  <span>ğŸ“Œ äº‹ä»¶</span>
                  <span class="tooltip-close" onclick="closeTooltip()">Ã—</span>
                </div>`;
              tooltipHTML += `<div class="tooltip-note">${renderNoteContent(pt.note, pt.noteImages || pt.noteImage)}</div>`;
            }
          }

          tooltip.innerHTML = tooltipHTML;
          // æ™ºèƒ½å®šä½
          positionTooltip(tooltip, e.clientX + 8, e.clientY + 8);
          tooltip.classList.add('show', 'pinned');

          // ç»‘å®šæ‹–æ‹½äº‹ä»¶åˆ°æ ‡é¢˜æ 
          const handle = document.getElementById('tooltip-drag-handle');
          if (handle) {
            handle.addEventListener('mousedown', function (ev) {
              isDraggingTooltip = true;
              const rect = tooltip.getBoundingClientRect();
              dragTooltipOffset.x = ev.clientX - rect.left;
              dragTooltipOffset.y = ev.clientY - rect.top;
              ev.preventDefault(); // é˜²æ­¢é€‰ä¸­æ–‡æœ¬
            });
          }
        }
      }
    });

    // å…¨å±€é¼ æ ‡ç§»åŠ¨å¤„ç†æ‹–æ‹½ï¼ˆåœ¨ document ä¸Šç›‘å¬ä»¥å…ç”©æ‰ï¼‰
    document.addEventListener('mousemove', function (e) {
      if (isDraggingTooltip) {
        const tooltip = document.getElementById('tooltip');
        if (tooltip) {
          tooltip.style.left = (e.clientX - dragTooltipOffset.x) + 'px';
          tooltip.style.top = (e.clientY - dragTooltipOffset.y) + 'px';
          // é˜²æ­¢æ‹–å‡ºè¾¹ç•Œå¯¼è‡´æ— æ³•æ‹–å›ï¼ˆå¯é€‰ï¼Œè¿™é‡Œå…ˆç®€å•é™åˆ¶ï¼‰
        }
        e.preventDefault();
      }
    });

    document.addEventListener('mouseup', function (e) {
      if (isDraggingTooltip) {
        isDraggingTooltip = false;
      }
    });

    // å…³é—­ tooltipï¼ˆè§£é™¤é”å®šï¼‰
    function closeTooltip() {
      const tooltip = document.getElementById('tooltip');
      tooltip.classList.remove('show', 'pinned');
    }

    // é˜»æ­¢ tooltip å†…æ»šè½®äº‹ä»¶å†’æ³¡åˆ°èƒŒåé¡µé¢
    document.getElementById('tooltip').addEventListener('wheel', function (e) {
      const tooltip = this;
      const scrollTop = tooltip.scrollTop;
      const scrollHeight = tooltip.scrollHeight;
      const clientHeight = tooltip.clientHeight;
      const deltaY = e.deltaY;

      // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ»šåŠ¨
      if (scrollHeight > clientHeight) {
        // å¦‚æœå·²ç»æ»šåˆ°é¡¶éƒ¨ä¸”ç»§ç»­å¾€ä¸Šæ»šï¼Œæˆ–è€…æ»šåˆ°åº•éƒ¨ä¸”ç»§ç»­å¾€ä¸‹æ»šï¼Œé˜»æ­¢é»˜è®¤è¡Œä¸º
        if ((scrollTop === 0 && deltaY < 0) ||
          (scrollTop + clientHeight >= scrollHeight && deltaY > 0)) {
          // å·²ç»åˆ°è¾¹ç•Œï¼Œé˜»æ­¢ç»§ç»­æ»šåŠ¨
          e.preventDefault();
        }
        // æ— è®ºå¦‚ä½•éƒ½é˜»æ­¢äº‹ä»¶å†’æ³¡
        e.stopPropagation();
      }
    }, { passive: false });

    // ç‚¹å‡»ç”»å¸ƒç©ºç™½å¤„å–æ¶ˆé”å®š
    canvas.addEventListener('click', function (e) {
      const tooltip = document.getElementById('tooltip');
      if (tooltip.classList.contains('pinned')) {
        const pos = getMousePos(e);
        const found = findItemAtPos(pos);
        // \u5982\u679c\u70b9\u51fb\u7684\u4e0d\u662f\u6709\u6ce8\u91ca\u7684\u5143\u7d20\uff0c\u5173\u95ed tooltip
        if (!found || !((found.type === 'entity' && (found.item.note || found.item.noteImage)) ||
          (found.type === 'invariant' && (found.item.note || found.item.noteImage)) ||
          (found.type === 'curvePoint' && (found.item.note || found.item.noteImage)))) {
          closeTooltip();
        }
      }
    });

    // å›¾ç‰‡æ”¾å¤§æŸ¥çœ‹
    function openImageViewer(imgSrc) {
      document.getElementById('imageViewerImg').src = imgSrc;
      document.getElementById('imageViewerOverlay').classList.add('show');
    }

    function closeImageViewer() {
      document.getElementById('imageViewerOverlay').classList.remove('show');
    }

    // ç›‘å¬ tooltip å†…çš„å›¾ç‰‡åŒå‡»
    document.addEventListener('dblclick', function (e) {
      if (e.target.tagName === 'IMG' && e.target.closest('.tooltip-note')) {
        openImageViewer(e.target.src);
      }
    });

    // äº‘ç«¯API + LocalStorageç¼“å­˜
    let cloudProjects = [];
    let isOnline = true;

    async function fetchCloudProjects() {
      try {
        const res = await fetch('/api/projects');
        if (res.ok) {
          cloudProjects = await res.json();
          isOnline = true;
          return cloudProjects;
        }
      } catch (err) {
        console.log('äº‘ç«¯è·å–å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°ç¼“å­˜:', err.message);
        isOnline = false;
      }
      return getLocalProjects();
    }

    function getLocalProjects() {
      try {
        const data = localStorage.getItem('ecosystemProjects');
        return data ? JSON.parse(data) : [];
      } catch { return []; }
    }

    function saveLocalProjects(projects) {
      localStorage.setItem('ecosystemProjects', JSON.stringify(projects));
    }

    async function updateProjectSelector() {
      const projects = await fetchCloudProjects();
      const selector = document.getElementById('projectSelector');
      const statusIcon = isOnline ? 'â˜ï¸' : 'ğŸ’¾';
      selector.innerHTML = `<option value="">${statusIcon} é€‰æ‹©é¡¹ç›®...</option>` +
        projects.map(p => `<option value="${p.id}" ${p.id === state.projectId ? 'selected' : ''}>${p.name}</option>`).join('');
    }

    function showNewProjectModal() {
      document.getElementById('newProjectName').value = '';
      document.getElementById('newProjectModal').classList.add('show');
    }

    async function createNewProject() {
      const name = document.getElementById('newProjectName').value.trim() || 'æœªå‘½åé¡¹ç›®';
      state = {
        projectId: generateId(),
        projectName: name,
        ecosystemName: '',
        singularityName: '',
        singularityDesc: '',
        phases: getDefaultPhases(),
        valueLayers: getDefaultLayers(),
        attributeTypes: getDefaultAttributes(),
        invariantTypes: state.invariantTypes,
        invariants: [],
        entities: [],
        connections: [],
        curvePoints: [],
        selectedItem: null,
        showCurvePoints: true,
        zoom: 1,
        styles: getDefaultStyles(),
        darkMode: state.darkMode
      };
      state.curvePoints = generateSpiralCurve(state.phases.length);
      undoStack = [];
      await saveProject();
      closeModal('newProjectModal');
      renderAll();
    }

    async function saveProject(silent = false) {
      if (!state.projectId) {
        state.projectId = generateId();
        state.projectName = 'æœªå‘½åé¡¹ç›®';
      }

      const projectData = {
        id: state.projectId,
        name: state.projectName,
        data: JSON.parse(JSON.stringify(state))
      };

      // æœ¬åœ°ç¼“å­˜
      const localProjects = getLocalProjects();
      const existingIdx = localProjects.findIndex(p => p.id === state.projectId);
      if (existingIdx >= 0) localProjects[existingIdx] = projectData;
      else localProjects.push(projectData);
      saveLocalProjects(localProjects);

      // äº‘ç«¯ä¿å­˜
      const btn = document.querySelector('.btn-primary');
      try {
        const res = await fetch('/api/projects', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(projectData)
        });
        if (res.ok) {
          isOnline = true;
          if (!silent) {
            btn.innerHTML = 'â˜ï¸ å·²åŒæ­¥';
            setTimeout(() => { btn.innerHTML = 'ä¿å­˜'; }, 1000);
          }
        } else {
          throw new Error('API error');
        }
      } catch (err) {
        isOnline = false;
        if (!silent) {
          btn.innerHTML = 'ğŸ’¾ æœ¬åœ°ä¿å­˜';
          setTimeout(() => { btn.innerHTML = 'ä¿å­˜'; }, 1000);
        }
      }

      await updateProjectSelector();
    }

    async function loadProject(projectId) {
      if (!projectId) return;

      let project = null;

      // å…ˆå°è¯•äº‘ç«¯è·å–
      try {
        const res = await fetch(`/api/projects/${projectId}`);
        if (res.ok) {
          const data = await res.json();
          project = { id: data.id, name: data.name, data: data.data };
          isOnline = true;
        }
      } catch (err) {
        console.log('äº‘ç«¯åŠ è½½å¤±è´¥ï¼Œå°è¯•æœ¬åœ°:', err.message);
        isOnline = false;
      }

      // æœ¬åœ°ç¼“å­˜
      if (!project) {
        const localProjects = getLocalProjects();
        project = localProjects.find(p => p.id === projectId);
      }

      if (project) {
        state = { ...project.data, invariantTypes: state.invariantTypes };
        if (!state.styles) state.styles = getDefaultStyles();
        if (state.darkMode === undefined) state.darkMode = true;
        if (state.zoom === undefined) state.zoom = 1;
        if (!state.curvePoints || state.curvePoints.length === 0) {
          state.curvePoints = generateSpiralCurve(state.phases.length);
        }
        // ç¡®ä¿å±‚çº§æœ‰é«˜åº¦æƒé‡
        state.valueLayers.forEach(l => { if (!l.heightWeight) l.heightWeight = 1; });
        undoStack = [];
        renderAll();
      }
    }

    function renameProject() {
      const newName = prompt('è¾“å…¥æ–°çš„é¡¹ç›®åç§°:', state.projectName);
      if (newName && newName.trim()) {
        state.projectName = newName.trim();
        saveProject();
      }
    }

    async function deleteCurrentProject() {
      if (!state.projectId) {
        alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªé¡¹ç›®');
        return;
      }
      if (!confirm(`ç¡®å®šè¦åˆ é™¤é¡¹ç›®"${state.projectName}"å—ï¼Ÿ\n\næ­¤æ“ä½œä¸å¯æ¢å¤ï¼`)) {
        return;
      }

      const projectIdToDelete = state.projectId;

      // åˆ é™¤æœ¬åœ°ç¼“å­˜
      const localProjects = getLocalProjects().filter(p => p.id !== projectIdToDelete);
      saveLocalProjects(localProjects);

      // åˆ é™¤äº‘ç«¯
      try {
        await fetch(`/api/projects/${projectIdToDelete}`, { method: 'DELETE' });
      } catch (err) {
        console.log('äº‘ç«¯åˆ é™¤å¤±è´¥:', err.message);
      }

      // åŠ è½½å…¶ä»–é¡¹ç›®
      const projects = await fetchCloudProjects();
      if (projects.length > 0) {
        await loadProject(projects[0].id);
      } else {
        state.projectId = null;
        state.projectName = 'æœªå‘½åé¡¹ç›®';
        await createNewProject();
      }
      await updateProjectSelector();
    }

    function exportProject() {
      const data = JSON.stringify(state, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `${state.projectName || 'ecosystem'}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    function showImportModal() {
      document.getElementById('importJsonText').value = '';
      // é»˜è®¤é€‰ä¸­"æ–°å»ºé¡¹ç›®"
      document.querySelector('input[name="importMode"][value="new"]').checked = true;
      document.getElementById('importModal').classList.add('show');
    }

    // è·å–å½“å‰é€‰ä¸­çš„å¯¼å…¥æ¨¡å¼
    function getImportMode() {
      const checked = document.querySelector('input[name="importMode"]:checked');
      return checked ? checked.value : 'new';
    }

    // è§¦å‘æ–‡ä»¶å¯¼å…¥ï¼ˆä¿å­˜å½“å‰æ¨¡å¼åå†å…³é—­å¼¹çª—ï¼‰
    let pendingImportMode = 'new';
    function triggerFileImport() {
      pendingImportMode = getImportMode();
      document.getElementById('importFile').click();
      closeModal('importModal');
    }

    function importProjectFromFile(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function (e) {
        processImportData(e.target.result, pendingImportMode);
      };
      reader.readAsText(file);
      event.target.value = '';
    }

    function importProjectFromText() {
      const jsonText = document.getElementById('importJsonText').value.trim();
      if (!jsonText) {
        alert('è¯·è¾“å…¥ JSON å†…å®¹');
        return;
      }
      const mode = getImportMode();
      closeModal('importModal');
      processImportData(jsonText, mode);
    }

    // å¢é‡å¯¼å…¥ï¼šåˆå¹¶æ–°æ•°æ®åˆ°å½“å‰é¡¹ç›®
    function mergeImportData(data) {
      saveStateForUndo();

      let addedInvariants = 0;
      let addedEntities = 0;
      let addedConnections = 0;

      // ç”»å¸ƒå°ºå¯¸ï¼ˆç”¨äºæ™ºèƒ½åæ ‡è®¡ç®—ï¼‰
      const mergeCanvasWidth = baseCanvasWidth || 800;
      const mergeCanvasHeight = baseCanvasHeight || 450;

      // ç”¨äºåŒä¸€å±‚çº§å†…çš„å…ƒç´ åˆ†æ•£å¸ƒå±€
      const layerElementCount = {};
      // ç»Ÿè®¡ç°æœ‰å…ƒç´ æ•°é‡
      state.invariants.forEach(inv => {
        if (!layerElementCount[inv.layerId]) layerElementCount[inv.layerId] = 0;
        layerElementCount[inv.layerId]++;
      });
      state.entities.forEach(ent => {
        if (!layerElementCount[ent.layerId]) layerElementCount[ent.layerId] = 0;
        layerElementCount[ent.layerId]++;
      });

      // åˆ›å»º ID æ˜ å°„è¡¨ï¼ˆæ—§ID -> æ–°IDï¼‰ç”¨äºæ›´æ–°è¿æ¥å…³ç³»
      const idMap = {};

      // åˆå¹¶ä¸åŠ¨ç‚¹
      if (data.invariants && data.invariants.length > 0) {
        data.invariants.forEach((inv, i) => {
          const oldId = inv.id;
          const newId = generateId();
          idMap[oldId] = newId;

          const layerId = inv.layerId || 1;
          if (!layerElementCount[layerId]) layerElementCount[layerId] = 0;
          const elementIndex = layerElementCount[layerId]++;

          // å¦‚æœæ²¡æœ‰æŒ‡å®šåæ ‡ï¼Œä½¿ç”¨æ™ºèƒ½è®¡ç®—
          let x = inv.x;
          let y = inv.y;
          if (x === undefined || y === undefined) {
            const phaseIndex = Math.min(elementIndex + 1, state.phases.length);
            const smartPos = calculateSmartPosition(layerId, phaseIndex, state.phases, state.valueLayers, mergeCanvasWidth, mergeCanvasHeight);
            if (x === undefined) x = smartPos.x + (elementIndex % 3) * 40;
            if (y === undefined) y = smartPos.y;
          }

          state.invariants.push({
            id: newId,
            typeId: inv.typeId || 'triangle',
            name: inv.name || `ä¸åŠ¨ç‚¹${state.invariants.length + 1}`,
            x: x,
            y: y,
            layerId: layerId,
            note: inv.note || '',
            noteImages: inv.noteImages || (inv.noteImage ? [inv.noteImage] : [])
          });
          addedInvariants++;
        });
      }

      // åˆå¹¶å…¬å¸/å®ä½“
      if (data.entities && data.entities.length > 0) {
        data.entities.forEach((ent, i) => {
          const oldId = ent.id;
          const newId = generateId();
          idMap[oldId] = newId;

          const layerId = ent.layerId || 1;
          if (!layerElementCount[layerId]) layerElementCount[layerId] = 0;
          const elementIndex = layerElementCount[layerId]++;

          // å¦‚æœæ²¡æœ‰æŒ‡å®šåæ ‡ï¼Œä½¿ç”¨æ™ºèƒ½è®¡ç®—
          let x = ent.x;
          let y = ent.y;
          if (x === undefined || y === undefined) {
            const phaseIndex = Math.min(elementIndex + 1, state.phases.length);
            const smartPos = calculateSmartPosition(layerId, phaseIndex, state.phases, state.valueLayers, mergeCanvasWidth, mergeCanvasHeight);
            if (x === undefined) x = smartPos.x + (elementIndex % 4) * 50;
            if (y === undefined) y = smartPos.y + (elementIndex % 2) * 25;
          }

          state.entities.push({
            id: newId,
            name: ent.name || `å…¬å¸${state.entities.length + 1}`,
            x: x,
            y: y,
            layerId: layerId,
            invariantId: ent.invariantId ? (idMap[ent.invariantId] || ent.invariantId) : null,
            primaryColor: ent.primaryColor || ent.color || '#6B7280',
            attributes: ent.attributes || [],
            note: ent.note || '',
            noteImages: ent.noteImages || (ent.noteImage ? [ent.noteImage] : [])
          });
          addedEntities++;
        });
      }

      // åˆå¹¶è¿æ¥å…³ç³»ï¼ˆæ›´æ–° ID å¼•ç”¨ï¼‰
      if (data.connections && data.connections.length > 0) {
        data.connections.forEach(conn => {
          const newSourceId = idMap[conn.sourceId] || conn.sourceId;
          const newTargetId = idMap[conn.targetId] || conn.targetId;

          // æ£€æŸ¥è¿æ¥çš„å…ƒç´ æ˜¯å¦å­˜åœ¨
          const sourceExists = (conn.sourceType === 'entity' && state.entities.some(e => e.id === newSourceId)) ||
            (conn.sourceType === 'invariant' && state.invariants.some(i => i.id === newSourceId));
          const targetExists = (conn.targetType === 'entity' && state.entities.some(e => e.id === newTargetId)) ||
            (conn.targetType === 'invariant' && state.invariants.some(i => i.id === newTargetId));

          if (sourceExists && targetExists) {
            state.connections.push({
              id: generateId(),
              sourceType: conn.sourceType,
              sourceId: newSourceId,
              targetType: conn.targetType,
              targetId: newTargetId
            });
            addedConnections++;
          }
        });
      }

      // è‡ªåŠ¨æ‰©å±•ç”»å¸ƒ
      autoExpandCanvasForData();
      saveProject();
      renderAll();

      alert(`è¡¥å……å¯¼å…¥æˆåŠŸï¼\næ–°å¢ï¼š${addedInvariants} ä¸ªä¸åŠ¨ç‚¹ï¼Œ${addedEntities} ä¸ªå…¬å¸ï¼Œ${addedConnections} æ¡è¿æ¥`);
    }

    function processImportData(jsonString, mode = 'new') {
      try {
        const data = JSON.parse(jsonString);

        // å¢é‡å¯¼å…¥æ¨¡å¼
        if (mode === 'merge') {
          // å¢é‡å¯¼å…¥åªéœ€è¦æœ‰å…ƒç´ æ•°æ®å³å¯ï¼Œä¸éœ€è¦é¡¹ç›®å
          if (!data.invariants && !data.entities) {
            alert('å¯¼å…¥å¤±è´¥ï¼šJSON ä¸­æ²¡æœ‰å¯å¯¼å…¥çš„å…ƒç´ ï¼ˆinvariants æˆ– entitiesï¼‰');
            return;
          }
          if (!state.projectId) {
            alert('è¯·å…ˆåˆ›å»ºæˆ–æ‰“å¼€ä¸€ä¸ªé¡¹ç›®ï¼Œå†ä½¿ç”¨è¡¥å……å¯¼å…¥åŠŸèƒ½');
            return;
          }
          mergeImportData(data);
          return;
        }

        // æ–°å»ºé¡¹ç›®æ¨¡å¼ï¼ˆåŸæœ‰é€»è¾‘ï¼‰
        if (!data.projectName && !data.ecosystemName) {
          alert('å¯¼å…¥å¤±è´¥ï¼šJSONæ ¼å¼ä¸æ­£ç¡®');
          return;
        }

        // å…ˆé¢„å¤„ç† phases å’Œ valueLayersï¼Œä»¥ä¾¿è®¡ç®—æ™ºèƒ½åæ ‡
        const importPhases = data.phases || getDefaultPhases();
        const importLayers = data.valueLayers || getDefaultLayers();

        // ç¡®ä¿ phases å’Œ layers æœ‰æ­£ç¡®çš„ id å’Œå±æ€§
        importPhases.forEach((p, i) => { if (!p.id) p.id = i + 1; });
        importLayers.forEach((l, i) => {
          if (!l.id) l.id = i + 1;
          if (!l.heightWeight) l.heightWeight = 1;
          if (!l.visiblePhases) l.visiblePhases = importPhases.map(p => p.id);
        });

        // è®¡ç®—ç”»å¸ƒå°ºå¯¸ï¼ˆç”¨äºæ™ºèƒ½åæ ‡è®¡ç®—ï¼‰
        const importCanvasWidth = baseCanvasWidth || 800;
        const importCanvasHeight = baseCanvasHeight || 450;

        // ç”¨äºåŒä¸€å±‚çº§å†…çš„å…ƒç´ åˆ†æ•£å¸ƒå±€
        const layerElementCount = {};

        state = {
          projectId: generateId(),
          projectName: data.projectName || data.ecosystemName || 'å¯¼å…¥é¡¹ç›®',
          ecosystemName: data.ecosystemName || '',
          singularityName: data.singularityName || '',
          singularityDesc: data.singularityDesc || '',
          phases: importPhases,
          valueLayers: importLayers,
          attributeTypes: data.attributeTypes || getDefaultAttributes(),
          invariantTypes: state.invariantTypes,
          invariants: (data.invariants || []).map((inv, i) => {
            const layerId = inv.layerId || 1;
            // ç»Ÿè®¡åŒä¸€å±‚çº§çš„å…ƒç´ æ•°é‡ï¼Œç”¨äºæ°´å¹³åˆ†æ•£
            if (!layerElementCount[layerId]) layerElementCount[layerId] = 0;
            const elementIndex = layerElementCount[layerId]++;

            // å¦‚æœæ²¡æœ‰æŒ‡å®šåæ ‡ï¼Œä½¿ç”¨æ™ºèƒ½è®¡ç®—
            let x = inv.x;
            let y = inv.y;
            if (x === undefined || y === undefined) {
              // æ ¹æ® layerId æ¨æ–­é˜¶æ®µï¼ˆç®€å•ç­–ç•¥ï¼šå‡åŒ€åˆ†å¸ƒï¼‰
              const phaseIndex = Math.min(elementIndex + 1, importPhases.length);
              const smartPos = calculateSmartPosition(layerId, phaseIndex, importPhases, importLayers, importCanvasWidth, importCanvasHeight);
              if (x === undefined) x = smartPos.x + (elementIndex % 3) * 40; // åŒé˜¶æ®µå†…æ°´å¹³åˆ†æ•£
              if (y === undefined) y = smartPos.y;
            }

            return {
              id: inv.id || generateId(),
              typeId: inv.typeId || 'triangle',
              name: inv.name || `ä¸åŠ¨ç‚¹${i + 1}`,
              x: x,
              y: y,
              layerId: layerId,
              note: inv.note || '',
              noteImages: inv.noteImages || (inv.noteImage ? [inv.noteImage] : [])
            };
          }),
          entities: (data.entities || []).map((ent, i) => {
            const layerId = ent.layerId || 1;
            // ç»Ÿè®¡åŒä¸€å±‚çº§çš„å…ƒç´ æ•°é‡
            if (!layerElementCount[layerId]) layerElementCount[layerId] = 0;
            const elementIndex = layerElementCount[layerId]++;

            // å¦‚æœæ²¡æœ‰æŒ‡å®šåæ ‡ï¼Œä½¿ç”¨æ™ºèƒ½è®¡ç®—
            let x = ent.x;
            let y = ent.y;
            if (x === undefined || y === undefined) {
              const phaseIndex = Math.min(elementIndex + 1, importPhases.length);
              const smartPos = calculateSmartPosition(layerId, phaseIndex, importPhases, importLayers, importCanvasWidth, importCanvasHeight);
              if (x === undefined) x = smartPos.x + (elementIndex % 4) * 50;
              if (y === undefined) y = smartPos.y + (elementIndex % 2) * 25; // å‚ç›´æ–¹å‘ä¹Ÿç¨å¾®åˆ†æ•£
            }

            return {
              id: ent.id || generateId(),
              name: ent.name || `å…¬å¸${i + 1}`,
              x: x,
              y: y,
              layerId: layerId,
              invariantId: ent.invariantId || null,
              primaryColor: ent.primaryColor || ent.color || '#6B7280',
              attributes: ent.attributes || [],
              note: ent.note || '',
              noteImages: ent.noteImages || (ent.noteImage ? [ent.noteImage] : [])
            };
          }),
          connections: data.connections || [],
          curvePoints: data.curvePoints || [],
          selectedItem: null,
          showCurvePoints: true,
          zoom: data.zoom || 1,
          styles: data.styles || getDefaultStyles(),
          darkMode: data.darkMode !== undefined ? data.darkMode : true
        };

        // phases å’Œ valueLayers å·²åœ¨å‰é¢é¢„å¤„ç†ï¼Œåªéœ€å¤„ç† attributeTypes
        state.attributeTypes.forEach(a => { if (!a.id) a.id = generateId(); });

        if (!state.curvePoints || state.curvePoints.length === 0) {
          state.curvePoints = generateSpiralCurve(state.phases.length);
        }

        undoStack = [];
        // è‡ªåŠ¨æ‰©å±•ç”»å¸ƒä»¥å®¹çº³æ‰€æœ‰å¯¼å…¥çš„å…ƒç´ 
        autoExpandCanvasForData();
        saveProject();
        renderAll();
        alert(`å¯¼å…¥æˆåŠŸï¼é¡¹ç›®"${state.projectName}"å·²åˆ›å»ºã€‚`);
      } catch (err) {
        console.error(err);
        alert('å¯¼å…¥å¤±è´¥ï¼š' + err.message);
      }
    }

    function closeModal(id) {
      document.getElementById(id).classList.remove('show');
    }

    // ========== åˆå§‹åŒ– ==========
    window.addEventListener('resize', () => {
      resizeCanvas();
      updateTogglePosition();
    });

    async function init() {
      state.phases = getDefaultPhases();
      state.valueLayers = getDefaultLayers();
      state.attributeTypes = getDefaultAttributes();
      // ä» LocalStorage åŠ è½½ä¿å­˜çš„æ ·å¼ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤æ ·å¼
      state.styles = loadStylesFromLocal();
      // ä» LocalStorage åŠ è½½ä¿å­˜çš„ç”»å¸ƒå°ºå¯¸è®¾ç½®
      loadCanvasSizeFromLocal();

      resizeCanvas();
      state.curvePoints = generateSpiralCurve(state.phases.length);

      // ä»äº‘ç«¯è·å–é¡¹ç›®åˆ—è¡¨
      const projects = await fetchCloudProjects();
      if (projects.length > 0) {
        await loadProject(projects[0].id);
      }

      renderAll();
      updateTogglePosition();
      startAutoSave();
    }

    init();
  </script>
</body>

</html>